{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Index page","text":"<p>Updated: 27/04/2023</p> <p>The course Python Tsunami is an 3-day introductory course to programming in the language Python. It is intended for researchers at SUND who are interested in learning how to use Python but who do not have any prior experience yet.</p> <p>We will demonstrate how to run Python from Jupyter Notebooks hosted on google colab, a tool that is often used for data analysis. An overview of the fundamental Pythonic data structures will follow and participants will learn about containers, conditional statements and loops. Moreover, the course will introduce the Python library pandas that allows for efficient data manipulation. Lastly, we will give a first introduction to data visualization in Python.</p> <p></p> <p>Henrike Zschach</p> <p>  Data Scientist </p> <p></p> <p>Ana Rita Cola\u00e7o</p> <p>  Data Scientist </p> <p>I\u00f1igo Prada Luengo</p> <p>  Postdoc </p> <p>Chloe Pittman</p> <p>  PhD Student </p> <p>Tugce Karaderi</p> <p>  Assistant Professor </p> <p>Viktoria Schuster</p> <p>  PhD Student </p> <p>J. A. Romero Herrera</p> <p>  Data Scientist </p> <p></p> <p>Overview</p> <p> Syllabus: </p> <ol> <li>Variables and data types</li> <li>Containers and iterables</li> <li>Conditions</li> <li>Loops</li> <li>Pandas and data frames</li> <li>Plotly visualizations</li> </ol> <p> Total Time Estimation: 8 hours  </p> <p> Target Audience: Anyone </p> <p> Level: Beginner</p> <p> License: Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license.</p> <p> Funding: This project was funded by the Novo Nordisk Fonden (NNF20OC0063268).</p> <p>Course Requirements</p> <p>This course has no requirements</p> <p>Goals</p> <p>By the end of this workshop, you should be able to:</p> <ul> <li>Understand basic python concepts such as variables, conditions, loops, etc</li> <li>Load your data and tables using Pandas</li> <li>Wrangle your data using Pandas</li> <li>Filtering</li> <li>Selection</li> <li>Merging</li> <li>Make interactive visualizations using Plotly</li> </ul>"},{"location":"index.html#python-tsunami-introduction-to-python-programming-language","title":"Python Tsunami: Introduction to Python programming language","text":""},{"location":"index.html#course-responsible","title":"Course responsible","text":""},{"location":"index.html#contributors","title":"Contributors","text":""},{"location":"index.html#course-information","title":"Course Information","text":""},{"location":"index.html#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Alberto Santos Delgado</li> <li>Henry Webel</li> <li>Annelaura Bach Nielsen</li> </ul>"},{"location":"contributors.html","title":"Contributors","text":"<p>Jose Alejandro Romero Herrera  </p>","tags":["authors","contributors"]},{"location":"contributors.html#credit-table","title":"CRediT table","text":"CRediT role Initials Conceptualization Data curation Formal Analysis Funding acquisition Investigation Methodology Project administration Resources Software Supervision Validation Visualization Writing - original draft Writing - review &amp; editing","tags":["authors","contributors"]},{"location":"keywords.html","title":"Keyword index","text":"<p>Here's a lit of used keywords:</p>"},{"location":"keywords.html#authors","title":"authors","text":"<ul> <li>Contributors</li> </ul>"},{"location":"keywords.html#contributors","title":"contributors","text":"<ul> <li>Contributors</li> </ul>"},{"location":"Conditionals/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [Conditions.ipynb](Conditions.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Conditionals/Conditions.ipynb) | Conditionals</p>"},{"location":"Conditionals/Conditions.html","title":"3. Conditions","text":"In\u00a0[28]: Copied! <pre>2 == 3\n</pre> 2 == 3 Out[28]: <pre>False</pre> In\u00a0[29]: Copied! <pre>2 &lt; 3\n</pre> 2 &lt; 3 Out[29]: <pre>True</pre> In\u00a0[30]: Copied! <pre>2 &gt; 3\n</pre> 2 &gt; 3 Out[30]: <pre>False</pre> <p>We will often use comparison operators between two variables, or between a variable and a value:</p> In\u00a0[4]: Copied! <pre>#assigning a variable\na = 2\n\n#Applying the comparison operator: Is a equal to 2? Well yes, we just defined it!\nprint(a == 2)\n</pre> #assigning a variable a = 2  #Applying the comparison operator: Is a equal to 2? Well yes, we just defined it! print(a == 2) <pre>True\n</pre> In\u00a0[3]: Copied! <pre>b = 3\n\n#Applying a comparison between two variables:\nprint(a == b)\n</pre> b = 3  #Applying a comparison between two variables: print(a == b) <pre>False\n</pre> <p>The following comparison operators exist between two integer variables: Assume <code>a = 2</code> and <code>b = 3</code> as above.</p> operator Description Result Example (<code>a, b = 2, 3</code>) <code>==</code> a equal to b True if a has the same value as b <code>a == b # False</code> <code>!=</code> a not equal to b True if a does NOT have the same value as b <code>a != b # True</code> <code>&gt;</code> a greater than b True if a is greater than b <code>a &gt; b # False</code> <code>&lt;</code> a less than b True if a is less than be b <code>a &lt; b # True</code> <code>&gt;=</code> a greater than or equal to b True if a is greater than or equal to b <code>a &gt;= b # False</code> <code>&lt;=</code> a less than or equal to b True if a is less than or equal to b <code>a &lt;= b # True</code> <p>Note: The result of a comparison is defined by the type of a and b, and the operator used.</p> <p>All conditional checks must always resolve to <code>True</code> or <code>False</code>, or an error if the two object types are not comparable.</p> In\u00a0[5]: Copied! <pre>#try it out!\nprint(a &gt; b)\nprint(a &lt; b)\nprint(a != b)\n</pre> #try it out! print(a &gt; b) print(a &lt; b) print(a != b) <pre>False\nTrue\nTrue\n</pre> In\u00a0[6]: Copied! <pre>#Just like a variable, we can also store the result of the comparison. It will be a boolean\n\nresult = a &gt; b\nprint(result)\nprint(type(result))\n</pre> #Just like a variable, we can also store the result of the comparison. It will be a boolean  result = a &gt; b print(result) print(type(result)) <pre>False\n&lt;class 'bool'&gt;\n</pre> <p>The same operators can also be applied to two string variables.</p> <p>Greater/smaller than comparisons are based on the alphanumeric sort:</p> In\u00a0[10]: Copied! <pre>print(\"a\" == \"b\")\nprint(\"a\" != \"b\")\n</pre> print(\"a\" == \"b\") print(\"a\" != \"b\") <pre>False\nTrue\n</pre> In\u00a0[13]: Copied! <pre>print(\"a\" &lt; \"b\")\nprint(\"a\" &gt; \"b\")\n\n#also works on multi character strings:\nprint(\"carl\" &lt; \"cbrl\")\n</pre> print(\"a\" &lt; \"b\") print(\"a\" &gt; \"b\")  #also works on multi character strings: print(\"carl\" &lt; \"cbrl\") <pre>True\nFalse\nTrue\n</pre> In\u00a0[14]: Copied! <pre>#Why is \"cdk10\" smaller than \"cdk8\"? \nprint(\"cdk10\" &lt; \"cdk8\")\n</pre> #Why is \"cdk10\" smaller than \"cdk8\"?  print(\"cdk10\" &lt; \"cdk8\") <pre>True\n</pre> In\u00a0[34]: Copied! <pre>a = 2\nb = 3\nprint(a == b)\nprint(a != b)\n</pre> a = 2 b = 3 print(a == b) print(a != b) <pre>False\nTrue\n</pre> <p>This works between all types of objects:</p> In\u00a0[43]: Copied! <pre>#comparing the equality of lists\nalist = [1, 2, 3]\nblist = [1, 2, 3]\nprint(alist == blist)\n\n#comparing dictionaries\nfood_dict = {\n    'fruit': ['banana', 'apple', 'strawberry'],\n    'veggies': ['eggplant', 'carrot']\n}\n\ncity_population = {\n    'Tokyo': 13350000, # a key-value pair\n    'Los Angeles': 18550000,\n    'New York City': 8400000,\n    'San Francisco': 1837442,\n}\n\nprint(food_dict == city_population)\n\n# we already saw == on integers and strings above\n</pre> #comparing the equality of lists alist = [1, 2, 3] blist = [1, 2, 3] print(alist == blist)  #comparing dictionaries food_dict = {     'fruit': ['banana', 'apple', 'strawberry'],     'veggies': ['eggplant', 'carrot'] }  city_population = {     'Tokyo': 13350000, # a key-value pair     'Los Angeles': 18550000,     'New York City': 8400000,     'San Francisco': 1837442, }  print(food_dict == city_population)  # we already saw == on integers and strings above <pre>True\nFalse\n</pre> In\u00a0[42]: Copied! <pre># empty list\na = []\nprint(bool(a))\n</pre> # empty list a = [] print(bool(a)) <pre>False\n</pre> In\u00a0[1]: Copied! <pre># 0, '' and None are False\na = 0\nb = None\nc = ''\n\nprint(bool(a))\nprint(bool(b))\nprint(bool(c))\n</pre> # 0, '' and None are False a = 0 b = None c = ''  print(bool(a)) print(bool(b)) print(bool(c)) <pre>False\nFalse\nFalse\n</pre> In\u00a0[\u00a0]: Copied! <pre># non-empty objects are True\na = [1,2,3]\nb = 5\nc = 'Hi!'\n\nprint(bool(a))\nprint(bool(b))\nprint(bool(c))\n</pre> # non-empty objects are True a = [1,2,3] b = 5 c = 'Hi!'  print(bool(a)) print(bool(b)) print(bool(c)) In\u00a0[23]: Copied! <pre># logical operator: and\n# will only return true if both conditions are true!\na = True\nb = True\n\nres1 = a and b\nprint(res1)\n</pre> # logical operator: and # will only return true if both conditions are true! a = True b = True  res1 = a and b print(res1) <pre>True\n</pre> In\u00a0[24]: Copied! <pre>c = False\nres2 = a and c\nprint(res2)\n</pre> c = False res2 = a and c print(res2) <pre>False\n</pre> In\u00a0[25]: Copied! <pre># logical operator: or\n# will return true if at least one of the conditions is true\n\n#remember a = True and c = False as defined above\nres3 = a or c\nprint(res3)\n</pre> # logical operator: or # will return true if at least one of the conditions is true  #remember a = True and c = False as defined above res3 = a or c print(res3) <pre>True\n</pre> In\u00a0[27]: Copied! <pre># logical operator: not\n# negates: True becomes False and False becomes True\n\n#remember a = True and c = False as defined above\nres4 = not a\nprint(res4)\nres5 = not c\nprint(res5)\n</pre> # logical operator: not # negates: True becomes False and False becomes True  #remember a = True and c = False as defined above res4 = not a print(res4) res5 = not c print(res5) <pre>False\nTrue\n</pre> In\u00a0[45]: Copied! <pre>aa = ['alanine', 'glycine', 'tyrosine']\n'alanine' in aa\n</pre> aa = ['alanine', 'glycine', 'tyrosine'] 'alanine' in aa Out[45]: <pre>True</pre> <p>Remember that strings are containers of characters, so <code>in</code> works on them as well!</p> In\u00a0[47]: Copied! <pre>print(aa[1])\n'gly' in aa[1]\n</pre> print(aa[1]) 'gly' in aa[1] <pre>glycine\n</pre> Out[47]: <pre>True</pre> In\u00a0[\u00a0]: Copied! <pre>my_s = \"Python is great!\"\n'great' in my_s\n</pre> my_s = \"Python is great!\" 'great' in my_s In\u00a0[55]: Copied! <pre># your code here\n</pre> # your code here <p>b. What about the result of this expression? Why is this the result?</p> <p>A hint: Check bool(y) and bool(x) individually.</p> <pre>x = 15\ny = 0\nbool(x or y)\n</pre> In\u00a0[56]: Copied! <pre># your code here\n</pre> # your code here  <p>c. What is the result of the following expression?</p> <pre>x = 0\ny = None\nx &lt; y\n</pre> <p>Can you compare x and y in a way that does not produce an error?</p> In\u00a0[60]: Copied! <pre># your code here\n</pre> # your code here <p>d. How can you find out if the following list contains 'Copenhagen'?</p> <pre>capitals = ['Berlin', 'London', 'Copenhagen', 'Madrid']\n</pre> In\u00a0[61]: Copied! <pre># your code here\n</pre> # your code here <p>The way we control flow in python is with indentation. It defines where a line of code belongs. Lines that are on the same level of indentation will be executed linearly, one after another. Lines on a different indentation level means there is some sort of flow control happening.</p> <pre>if some condition is True:\n    do something\n    everything I write here is part of the if block\n    it will only be executed if the condition is true \n    more commands\n\n#when we return to the outermost indentation level python knows the if block is over    \nelif some other condition is True:\n    do something else\n\nelse:\n    do something\n</pre> <p>Conditional statements use the keywords <code>if</code>, <code>elif</code> and <code>else</code>, and they let you control which pieces of code are run based on the value of some Boolean condition.</p> <p>The basic syntax of an <code>if</code> block is:</p> <pre>if some condition is True:\n    do something\nelif some other condition is True:\n    do something\nelse:\n    do something\n</pre> <ul> <li>The lines containing <code>if</code>, <code>elif</code> and <code>else</code> always need to end with a <code>:</code> (colon).</li> <li>Only <code>if</code> and <code>elif</code> are followed by conditions, whereas <code>else</code> is never followed by anything else than a <code>:</code> (colon).</li> <li><code>if</code> and <code>elif</code> are exclusive. They cannot simultaneously be true! In fact, the <code>elif</code> condition will only be checked if the <code>if</code> condition is False.</li> <li>Code to be executed if the condition is True always needs to be indented.</li> </ul> In\u00a0[3]: Copied! <pre># if/else\n\nage = 23\n\nif age &gt;= 18:\n    print(\"Here's your beer\")\nelse:\n    print(\"Come back when you're 18!\")\n</pre> # if/else  age = 23  if age &gt;= 18:     print(\"Here's your beer\") else:     print(\"Come back when you're 18!\")  <pre>Here's your beer\n</pre> <p>The condition to be checked can also be a boolean itself! For example:</p> In\u00a0[2]: Copied! <pre># if/else\n\nis_weekend = True\n\nif not is_weekend:\n    print(\"It's Monday.\")\n    print(\"Go to work.\")\nelse:\n    print(\"Sleep in and enjoy the beach.\")\n</pre> # if/else  is_weekend = True  if not is_weekend:     print(\"It's Monday.\")     print(\"Go to work.\") else:     print(\"Sleep in and enjoy the beach.\")      <pre>Sleep in and enjoy the beach.\n</pre> In\u00a0[1]: Copied! <pre># if/elif/else\n# the elif condition will only be checked if the if condition is False\n\nbirth_year = 1950\n\nif birth_year &lt; 1964:\n    print('Ok, boomer.')\nelif birth_year &lt; 1990:\n    print(\"Sorry, the 90's was not 15 years ago. That's 2008.\")\nelse:\n    print(\"Yeah yeah, talk to me when you're a grown-up, zoomer\")\n</pre> # if/elif/else # the elif condition will only be checked if the if condition is False  birth_year = 1950  if birth_year &lt; 1964:     print('Ok, boomer.') elif birth_year &lt; 1990:     print(\"Sorry, the 90's was not 15 years ago. That's 2008.\") else:     print(\"Yeah yeah, talk to me when you're a grown-up, zoomer\") <pre>Ok, boomer.\n</pre> In\u00a0[\u00a0]: Copied! <pre>name = \"\"\nif name == \"Gandalf\":\n    print(\"Run, you fools!\")\nelif name == \"Aragorn\":\n    print(\"There is always hope.\")\nelse:\n    print(\"Move on then!\")\n</pre> name = \"\" if name == \"Gandalf\":     print(\"Run, you fools!\") elif name == \"Aragorn\":     print(\"There is always hope.\") else:     print(\"Move on then!\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Conditionals/Conditions.html#booleans-and-conditional-logic","title":"Booleans and Conditional logic\u00b6","text":""},{"location":"Conditionals/Conditions.html#booleans","title":"Booleans\u00b6","text":"<p>A Boolean is a datatype that can only take two values: <code>True</code> or <code>False</code>.</p>"},{"location":"Conditionals/Conditions.html#comparison-operators","title":"Comparison Operators\u00b6","text":"<p>Comparison operators tell how two Python values relate and they always result in a boolean (True or False). In other words, they answer yes/no questions.</p>"},{"location":"Conditionals/Conditions.html#equality","title":"Equality\u00b6","text":"<p>More generally, we can test the equality of two variables or objects with the equality operator <code>==</code>.</p> Operator Description Example (<code>a, b = 2, 3</code>) <code>==</code> True if both sides evaluate to the same <code>a == 2 # True</code> <code>==</code> True if both sides evaluate to the same <code>a == b # False</code> <code>!=</code> True if both side do not evaluate to the same <code>a != b # True</code> <code>!=</code> True if both side do not evaluate to the same <code>a != 3 # True</code> <p>There is also the identity operator <code>is</code>, but it does something different than <code>==</code> and the explanation goes beyound the scope of this course. You can read about it here if you're curious. For now, in 99% of case you actually want <code>==</code>.</p>"},{"location":"Conditionals/Conditions.html#exercise-1","title":"Exercise 1\u00b6","text":"<p>~ 5 minutes</p> <p>a. What will be the result of this comparison?</p> <pre>x = 2\n    y = \"Anthony\"\n    x &lt; y\n</pre> <ol> <li><code>True</code></li> <li><code>False</code></li> <li>Error</li> </ol> <p>b. What about this comparison?</p> <pre>x = 12.99\n    y = 12\n    x &gt;= y\n</pre> <ol> <li><code>True</code></li> <li><code>False</code></li> <li>Error</li> </ol> <p>c. And this comparison?</p> <pre>x = 5\n    y = \"Hanna\"\n    x == y\n</pre> <ol> <li><code>True</code></li> <li><code>False</code></li> <li>Error</li> </ol>"},{"location":"Conditionals/Conditions.html#truthiness","title":"Truthiness\u00b6","text":"<p>In addition to comparing objects to each other, it is important to note that all Python objects are by themselves either <code>True</code> or <code>False</code>. We call this concept Truthiness.</p> <pre>x = 1\ny = 0\nbool(x) # True\nbool(y) # False\n</pre> <p>Empty objects such as empty lists/tuples/arrays/strings, the <code>None</code> object, and the <code>int</code> <code>0</code> and <code>float</code> <code>0.0</code> are by definition False.</p> <p>All non-empty objects are by definition True.</p>"},{"location":"Conditionals/Conditions.html#logical-operators","title":"Logical Operators\u00b6","text":"<p>Logical operators are used in conditional statements.</p> <ul> <li><code>and</code>, True if both a AND b are true (logical conjunction)</li> <li><code>or</code>, True if either a OR b are true (logical disjunction)</li> <li><code>not</code>, True if the opposite of a is true (logical negation)</li> </ul>"},{"location":"Conditionals/Conditions.html#membership-operators","title":"Membership operators\u00b6","text":"<p>Membership operators test whether a certain element is part of a container.</p> Operator Description Example (<code>a = [1, 2, 3]</code>) <code>in</code> True if value/variable is found in the sequence <code>2 in a # True</code> <code>not in</code> True if value/variable is not found in the sequence <code>5 not in a # False</code>"},{"location":"Conditionals/Conditions.html#exercise-2","title":"Exercise 2\u00b6","text":"<p>~10 minutes</p> <p>a.  What is the result of the following expression?</p> <pre>a = True\nb = False\na or b\n</pre> <p>What do you need to change to make this expression evaluate to <code>False</code>?</p>"},{"location":"Conditionals/Conditions.html#flow-of-code","title":"Flow of code\u00b6","text":"<p>So far we have made code that flows linearly. The statements are executed one after each other like here:</p> <pre>my_var = 1\n\nmy_var += 10\n\nprint(my_var)\n\nprint(my_var == 11)\n</pre> <p>You can see, all lines start at the same left edge of the page. We say they are on the same indentation level.</p> <p>But often when we program we want different things to happen depending on a condition:</p>"},{"location":"Conditionals/Conditions.html#conditional-statements","title":"Conditional Statements\u00b6","text":""},{"location":"Conditionals/Conditions.html#exercise","title":"Exercise\u00b6","text":"<p>~ 5 minutes</p> <p>If you set the name variable to \"Gandalf\" and run the script below, what will the output be? How do you get the output 'Move on then'?</p>"},{"location":"Conditionals/Conditions.html#exercise-3","title":"Exercise 3\u00b6","text":"<p>~ 10-15 minutes</p> <p>Create a variable and assign an integer as value, then build a conditional to test it:</p> <ul> <li>If the value is below 0, print \"The value is negative\".</li> <li>If the value is between 0 and 20 (including 0 and 20), print the value.</li> <li>Otherwise, print \"Out of scope\".</li> </ul> <p>Test it by changing the value of the variable.</p>"},{"location":"Exercise/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [Exercise_jan2023.ipynb](Exercise_jan2023.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Exercise/Exercise_jan2023.ipynb) | Exercise</p>"},{"location":"Iterables/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [iterables.ipynb](iterables.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Iterables/iterables.ipynb) | Data structures</p>"},{"location":"Iterables/iterables.html","title":"2. Iterables","text":"In\u00a0[\u00a0]: Copied! <pre>#declare an empty list\nempty_list = []\nprint(empty_list)\n</pre> #declare an empty list empty_list = [] print(empty_list) In\u00a0[\u00a0]: Copied! <pre>#declare a list with soem items\ntasks = [\"Install Python\", \"Learn Python\", \"Take a break\"]\nprint(tasks)\n</pre> #declare a list with soem items tasks = [\"Install Python\", \"Learn Python\", \"Take a break\"] print(tasks) <ul> <li>To find out how many elements there are in a list, you can use the built-in function <code>len</code>.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>len(tasks)\n</pre> len(tasks) In\u00a0[\u00a0]: Copied! <pre>friends = [\"Rachel\", \"Monica\", \"Phoebe\"]\n</pre> friends = [\"Rachel\", \"Monica\", \"Phoebe\"] In\u00a0[\u00a0]: Copied! <pre>friends[0]\n</pre> friends[0] In\u00a0[\u00a0]: Copied! <pre>print(friends[2]) \nprint(friends[3]) # IndexError\n</pre> print(friends[2])  print(friends[3]) # IndexError <p>To access values from the end, you can use a negative number to index backwards:</p> In\u00a0[\u00a0]: Copied! <pre>print(friends[-1])\n</pre> print(friends[-1]) In\u00a0[\u00a0]: Copied! <pre>print(friends[-3])\nprint(friends[-4]) # IndexError\n</pre> print(friends[-3]) print(friends[-4]) # IndexError <p>Setting elements</p> <p>You can set, i.e. re-define elements in an existing list with the assignment operator</p> In\u00a0[\u00a0]: Copied! <pre>print(friends)\nprint(friends[1])\nfriends[1] = 'Chandler'\nprint(friends)\n</pre> print(friends) print(friends[1]) friends[1] = 'Chandler' print(friends) <p>To check if a value is in a list, you can use the <code>in</code> operator:</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Rachel\" in friends) \nprint(\"Jason\" in friends)\nprint(\"rachel\" in friends)\n</pre> print(\"Rachel\" in friends)  print(\"Jason\" in friends) print(\"rachel\" in friends)  In\u00a0[1]: Copied! <pre>friends = [\"Rachel\", \"Monica\", \"Phoebe\", 'Joey', 'Chandler', 'Ross']\n</pre> friends = [\"Rachel\", \"Monica\", \"Phoebe\", 'Joey', 'Chandler', 'Ross'] <p>If you don't specify the <code>end</code> parameter the slice will extend all the way to the end of the list:</p> In\u00a0[\u00a0]: Copied! <pre>#only using the start parameter\n\n# slice from index 1 (this is the second element in the list) and all the way to the end\nprint(friends[1:])\n\n# slice from index 2\nprint(friends[2:])\n</pre> #only using the start parameter  # slice from index 1 (this is the second element in the list) and all the way to the end print(friends[1:])  # slice from index 2 print(friends[2:])  <p>We can also negate the parameter to count from the back, like we did when accessing single values.</p> In\u00a0[\u00a0]: Copied! <pre># slice starting from the third element from the back and going forwards\nprint(friends[-3:])\n</pre> # slice starting from the third element from the back and going forwards print(friends[-3:]) <p>We can include the <code>end</code> parameter to extract a slice from element 2 to 4.</p> <p>Be mindful that the <code>end</code> itself is not included! Also, remember that the first element is at index 0, not index 1. It takes some practise to get exactly the part you want.</p> In\u00a0[\u00a0]: Copied! <pre># slice from index 2 to 4\nprint(friends[2:5]) \n\n# slice starting from index 2 up to (but excluding) index 4\nprint(friends[2:4])\n</pre> # slice from index 2 to 4 print(friends[2:5])   # slice starting from index 2 up to (but excluding) index 4 print(friends[2:4])  <p>When we do not specify the <code>start</code> it will automatically be the beginning of the list (index 0). Notice that we have to put a colon <code>:</code> in front of the <code>end</code> parameter so python knows it's the <code>end</code>, not the <code>start</code>.</p> In\u00a0[\u00a0]: Copied! <pre># slice up to (but excluding) index 4\nprint(friends[:4])\n</pre> # slice up to (but excluding) index 4 print(friends[:4])  <p>The <code>end</code> parameter can be negative, just like the the <code>start</code>. In that case we count from the end of the list.</p> In\u00a0[\u00a0]: Copied! <pre># slice up to the (but excluding) the last element\n# = the first element from the end\nprint(friends[:-1])\n</pre> # slice up to the (but excluding) the last element # = the first element from the end print(friends[:-1]) <p>The <code>step</code> parameter indicated that step size. If you leave it out, the step size is 1. This was done in all the examples so far.</p> <p>By modifying the step size we can do things like accessing only every nth element:</p> In\u00a0[\u00a0]: Copied! <pre># access entire list from start to end, but only count every other element\nprint(friends[::2])\n</pre> # access entire list from start to end, but only count every other element print(friends[::2]) <p>When the step size is negative we move in the opposite direction, i.e. from the end towards the front of the list.</p> In\u00a0[\u00a0]: Copied! <pre>print(friends[::-1])\n</pre> print(friends[::-1]) In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here In\u00a0[\u00a0]: Copied! <pre>sund_centers = ['BRIC', 'CPR', 'CBMR', 'reNEW', 'CTN', 'HeaDS', 'Globe', 'Vet', 'Pharma']\n\n###\n# your code goes below\n###\n\n# display the first element in sund_centers\n\n# display the last element in sund_centers\n\n# display all but the last element in sund_centers\n\n# display the last 3 elements\n\n# display every second element\n\n# display ever second element starting from 'CPR'\n</pre> sund_centers = ['BRIC', 'CPR', 'CBMR', 'reNEW', 'CTN', 'HeaDS', 'Globe', 'Vet', 'Pharma']  ### # your code goes below ###  # display the first element in sund_centers  # display the last element in sund_centers  # display all but the last element in sund_centers  # display the last 3 elements  # display every second element  # display ever second element starting from 'CPR'  <p>Quiz</p> <p>Given a list <code>numbers = ['one','two','three','four']</code> - what do the following slices return and why?</p> <ul> <li><p>slice 1 <code>numbers[::-1]</code>:</p> <p>(a) <code>['one','two','three','four']</code>   (b) <code>['one','four']</code>   (c) <code>['four','three','two','one']</code>   (d) <code>['four']</code></p> </li> <li><p>slice 2: <code>numbers[1:3]</code> :</p> <p>(a) <code>['one','two','three']</code>   (b) <code>['two','three']</code>   (c) <code>['two','three','four']</code>   (d) <code>['one','two']</code>   (e) <code>['three']</code></p> </li> <li><p>slice 3: <code>numbers[-2]</code> :</p> <p>(a) <code>['three']</code>   (b) <code>'three'</code>   (c) <code>['one','two','three']</code>   (d) <code>['two']</code>   (e) <code>'two</code></p> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># if you are unsure, just try it out here\n</pre> # if you are unsure, just try it out here In\u00a0[\u00a0]: Copied! <pre>people = [\"Petre\",\"Joanna\",\"Louis\",\"Angie\",\"Monika\",\"george\"]\n</pre> people = [\"Petre\",\"Joanna\",\"Louis\",\"Angie\",\"Monika\",\"george\"] In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here In\u00a0[\u00a0]: Copied! <pre>nested_list = [[1, 2, 3],\n               [4, 5, 6],\n               [7, 8, 9]]\nprint(nested_list)\n</pre> nested_list = [[1, 2, 3],                [4, 5, 6],                [7, 8, 9]] print(nested_list) <p>You access the individual sublists in the same way as we accessed simple elements before:</p> In\u00a0[\u00a0]: Copied! <pre># returns the first sublist\nnested_list[0]\n</pre> # returns the first sublist nested_list[0] <p>To access an element inside a sublist of a list, you first need to access the sublist by its index and then the element in the sublist by its index in the sublist:</p> In\u00a0[\u00a0]: Copied! <pre># This will return 2, the 1st element in the 0th sublist.\nnested_list[0][1]\n</pre> # This will return 2, the 1st element in the 0th sublist. nested_list[0][1]  <p>Did you know that strings behave a lot like lists, too? They are what we call <code>subscriptable</code>. A string is not a simple element like an integer. It consists of a sequence of characters, which you can access just like list elements.</p> In\u00a0[\u00a0]: Copied! <pre>my_string = \"Programming is fun!\"\nprint(my_string[:11])\nprint(my_string[-4:])\nprint(my_string[::-1])\n</pre> my_string = \"Programming is fun!\" print(my_string[:11]) print(my_string[-4:]) print(my_string[::-1]) In\u00a0[\u00a0]: Copied! <pre># append\nfirst_list = ['one', 'two', 'three', 'four']\nfirst_list.append('five')\nprint(first_list)\n</pre> # append first_list = ['one', 'two', 'three', 'four'] first_list.append('five') print(first_list) In\u00a0[\u00a0]: Copied! <pre># but careful with this one!\nfirst_list = ['one', 'two', 'three', 'four']\nfirst_list.append(['five','six'])\nprint(first_list)\n</pre> # but careful with this one! first_list = ['one', 'two', 'three', 'four'] first_list.append(['five','six']) print(first_list) In\u00a0[\u00a0]: Copied! <pre># extend\ncorrect_list = ['one', 'two', 'three', 'four']\ncorrect_list.extend(['five','six', 'seven', 'eight'])\nprint(correct_list)\n</pre> # extend correct_list = ['one', 'two', 'three', 'four'] correct_list.extend(['five','six', 'seven', 'eight']) print(correct_list)  In\u00a0[\u00a0]: Copied! <pre># insert\nfirst_list = ['one', 'two', 'three', 'four']\nfirst_list.insert(2, 'Hi!')\nprint(first_list)\n</pre> # insert first_list = ['one', 'two', 'three', 'four'] first_list.insert(2, 'Hi!') print(first_list)  <p>Removing elements from a list:</p> <ul> <li><code>clear</code>: remove all items from a list.</li> <li><code>pop</code><ul> <li>Remove the item at the given position in the list, and return it.</li> <li>If no index is specified, removes &amp; returns last item in the list.</li> </ul> </li> <li><code>del</code>: deletes a value from a list.</li> </ul> In\u00a0[\u00a0]: Copied! <pre># clear\nfirst_list = ['one', 'two', 'three', 'four']\nfirst_list.clear()\nprint(first_list)\n</pre> # clear first_list = ['one', 'two', 'three', 'four'] first_list.clear() print(first_list) In\u00a0[\u00a0]: Copied! <pre># pop\nfirst_list = ['one', 'two', 'three', 'four']\nlast_item = first_list.pop() \nprint(last_item)\nsecond_item = first_list.pop(1) \nprint(second_item)\n\n# the elements are then not in the list anymore\nprint(first_list)\n</pre> # pop first_list = ['one', 'two', 'three', 'four'] last_item = first_list.pop()  print(last_item) second_item = first_list.pop(1)  print(second_item)  # the elements are then not in the list anymore print(first_list) In\u00a0[\u00a0]: Copied! <pre># del \nfirst_list = ['one', 'two', 'three', 'four']\ndel first_list[3]\nprint(first_list)\ndel first_list[1]\nprint(first_list)\n</pre> # del  first_list = ['one', 'two', 'three', 'four'] del first_list[3] print(first_list) del first_list[1] print(first_list) <p>Other useful list methods:</p> <ul> <li><code>count</code>: return the number of times x appears in the list.</li> <li><code>sort</code>: sort the items of the list (in-place).</li> <li><code>copy</code>: take a list and assign a copy to a new variable.</li> </ul> In\u00a0[\u00a0]: Copied! <pre># count\nnumbers = [1, 2, 3, 4, 3, 2, 1, 4, 10, 2]\n\n# count how often 2 appears in the list\nprint(numbers.count(2))\n\n# count how often 21 appears in the list\nprint(numbers.count(21))\n</pre> # count numbers = [1, 2, 3, 4, 3, 2, 1, 4, 10, 2]  # count how often 2 appears in the list print(numbers.count(2))  # count how often 21 appears in the list print(numbers.count(21)) In\u00a0[\u00a0]: Copied! <pre># sort\nanother_list = [6, 4, 1, 2, 5]\nanother_list.sort()\nprint(another_list)\n</pre> # sort another_list = [6, 4, 1, 2, 5] another_list.sort() print(another_list) In\u00a0[\u00a0]: Copied! <pre># copy\nunsorted_list = [6, 4, 1, 2, 5]\n\n# just assigning a list to a new variable name does not copy it\n# you now simply have to variable names pointing to the same list\nsorted_list = unsorted_list\nsorted_list.sort()\nprint(sorted_list)\nprint(unsorted_list)\n</pre> # copy unsorted_list = [6, 4, 1, 2, 5]  # just assigning a list to a new variable name does not copy it # you now simply have to variable names pointing to the same list sorted_list = unsorted_list sorted_list.sort() print(sorted_list) print(unsorted_list) In\u00a0[\u00a0]: Copied! <pre># this is the way to copy a list\nimport copy\n\nunsorted_list = [6, 4, 1, 2, 5]\n\nsorted_list = copy.deepcopy(unsorted_list)\nsorted_list.sort()\nprint(sorted_list)\nprint(unsorted_list)\n</pre> # this is the way to copy a list import copy  unsorted_list = [6, 4, 1, 2, 5]  sorted_list = copy.deepcopy(unsorted_list) sorted_list.sort() print(sorted_list) print(unsorted_list) <p>Find the instructions as comments.</p> In\u00a0[6]: Copied! <pre>shopping_list = [['apples','bananas','oranges'],\n                 ['milk', 'eggs', 'cheese'],\n                 ['soap', 'toothbrush', 'tissues']]\n\n\n# your code goes here\n\n\n# add one item to every sublist in shopping_list\n\n# remove the last sublist from shopping_list\n\n# make a copy of the shopping list called new_list\n\n# make new_list a 'flat' list (non-nested) without changing the original shopping_list\n# Tip: take the first sublist and extend it with the second\n</pre> shopping_list = [['apples','bananas','oranges'],                  ['milk', 'eggs', 'cheese'],                  ['soap', 'toothbrush', 'tissues']]   # your code goes here   # add one item to every sublist in shopping_list  # remove the last sublist from shopping_list  # make a copy of the shopping list called new_list  # make new_list a 'flat' list (non-nested) without changing the original shopping_list # Tip: take the first sublist and extend it with the second  In\u00a0[\u00a0]: Copied! <pre># create a set\nnumber_set = {1,2,3}\n</pre> # create a set number_set = {1,2,3} <p>Why is this useful?</p> <p>I personally like it to get all unique values in a list.</p> In\u00a0[\u00a0]: Copied! <pre>my_list = [1,4,7,1,2,3,3,7,2,7,7,1]\nset(my_list)\n</pre> my_list = [1,4,7,1,2,3,3,7,2,7,7,1] set(my_list) <p>Having set objects allows you to perform set operations such as:</p> <ul> <li>union</li> <li>intersection</li> <li>set difference</li> </ul> In\u00a0[\u00a0]: Copied! <pre>fav_foods = {'pizza', 'pasta', 'sushi','ice cream'}\n\ndeserts = {'cake', 'pancake', 'ice cream'}\ncarbs = {'pizza', 'pasta', 'potatoes'}\nasian_foods = {'pho', 'stir fry', 'sushi'}\n</pre> fav_foods = {'pizza', 'pasta', 'sushi','ice cream'}  deserts = {'cake', 'pancake', 'ice cream'} carbs = {'pizza', 'pasta', 'potatoes'} asian_foods = {'pho', 'stir fry', 'sushi'}   In\u00a0[\u00a0]: Copied! <pre># Which of my favorite foods are also carbs?\n\nfav_foods.intersection(carbs)\n</pre> # Which of my favorite foods are also carbs?  fav_foods.intersection(carbs) In\u00a0[\u00a0]: Copied! <pre># Its diet week and we're not having desert. Which foods are left from the favorite set?\n# Notice that difference is directional! What do you get if you swap the sets below?\n\nfav_foods - deserts\n</pre> # Its diet week and we're not having desert. Which foods are left from the favorite set? # Notice that difference is directional! What do you get if you swap the sets below?  fav_foods - deserts In\u00a0[\u00a0]: Copied! <pre># Lets say a restaurant wants to do everything from the deserts and carbs sets, whats their entire menu?\nmenu = deserts.union(carbs)\nmenu\n</pre> # Lets say a restaurant wants to do everything from the deserts and carbs sets, whats their entire menu? menu = deserts.union(carbs) menu In\u00a0[\u00a0]: Copied! <pre># define dictionary\ncity_population = {\n    'Tokyo': 13350000, # a key-value pair\n    'Los Angeles': 18550000,\n    'New York City': 8400000,\n    'San Francisco': 1837442,\n}\n\n# display dictionary\ncity_population\n</pre> # define dictionary city_population = {     'Tokyo': 13350000, # a key-value pair     'Los Angeles': 18550000,     'New York City': 8400000,     'San Francisco': 1837442, }  # display dictionary city_population In\u00a0[\u00a0]: Copied! <pre># access the value for the key 'New York City'\nprint(city_population['New York City'])\n</pre> # access the value for the key 'New York City' print(city_population['New York City']) <p>Change values by specifying the key and using the <code>=</code> operator:</p> In\u00a0[\u00a0]: Copied! <pre>city_population['New York City'] = 73847834\ncity_population\n</pre> city_population['New York City'] = 73847834 city_population <p>To add a new (key, value) pair, you can choose between different ways:</p> In\u00a0[\u00a0]: Copied! <pre># using the = operator\ncity_population['Copenhagen'] = 1000000\n\n# using the update method\ncity_population.update({'Barcelona': 5000000})\n\ncity_population\n</pre> # using the = operator city_population['Copenhagen'] = 1000000  # using the update method city_population.update({'Barcelona': 5000000})  city_population <p>A dictionary can hold complex data types as values:</p> In\u00a0[\u00a0]: Copied! <pre>food = {\"fruits\": [\"apple\", \"orange\"], \"vegetables\": [\"carrot\", \"eggplant\"]}\n</pre> food = {\"fruits\": [\"apple\", \"orange\"], \"vegetables\": [\"carrot\", \"eggplant\"]} In\u00a0[\u00a0]: Copied! <pre># access the value of the key \"fruits\"\nprint(food[\"fruits\"])\n\n# access element at index 0 in the list\nprint(food[\"fruits\"][0])\n</pre> # access the value of the key \"fruits\" print(food[\"fruits\"])  # access element at index 0 in the list print(food[\"fruits\"][0]) <p>To remove a (key, value) pair from the dictionary:</p> In\u00a0[\u00a0]: Copied! <pre>food\n</pre> food In\u00a0[\u00a0]: Copied! <pre>del food['vegetables']\n</pre> del food['vegetables'] In\u00a0[\u00a0]: Copied! <pre>food\n</pre> food In\u00a0[\u00a0]: Copied! <pre># create a tuple\nt = (5, 6)       \n\n# equal formulation \n#t = 5, 6       \n\nt\n</pre> # create a tuple t = (5, 6)         # equal formulation  #t = 5, 6         t In\u00a0[\u00a0]: Copied! <pre># a tuple can have an arbitrary amount of elements:\nt2 = (1,2,5,3,8,11)\nt2\n</pre> # a tuple can have an arbitrary amount of elements: t2 = (1,2,5,3,8,11) t2 <ol> <li>Create a dictionary with 4 elements.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Create a dictionary called countries where the key is the country and the value is a (non-exhaustive) list of cities in the country.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Access one of the keys.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Access one of the values, i.e. cities belonging to that key.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Add another country and its list of cities.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Remove one of the countries and its elements.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Iterables/iterables.html#containers","title":"Containers\u00b6","text":"<p>You were previously introduced to the following basic data types in Python: <code>Boolean</code>, <code>int</code>, <code>float</code> and <code>str</code>. There are more fundamental data structures in Python which you will learn about in this notebook.</p> <p>These collections of data types are like containers that can contain several items. In particular, this notebook covers:</p> <ul> <li><code>list</code></li> <li><code>set</code></li> <li><code>tuple</code></li> <li><code>dictionary</code></li> </ul>"},{"location":"Iterables/iterables.html#lists-part-1","title":"Lists part 1\u00b6","text":"<p>A list is a container of ordered elements that can be accessed by their index.</p> <ul> <li>To create an empty list use square brackets <code>[]</code></li> <li>The elements in a list are separated by commas.</li> </ul>"},{"location":"Iterables/iterables.html#accessing-values-in-a-list","title":"Accessing values in a <code>list</code>\u00b6","text":"<p>The elements in a list are ordered and can thus be accessed by their index. Lists start counting at <code>0</code>,  i.e. the first element in your list lives at the index position <code>0</code>.</p>"},{"location":"Iterables/iterables.html#accessing-single-elements","title":"Accessing single elements\u00b6","text":""},{"location":"Iterables/iterables.html#accessing-multiple-elements-slicing","title":"Accessing multiple elements: slicing\u00b6","text":"<p>To access several elements at once, you can use a technique called slicing:</p> <pre>some_list[start:end:step]\n</pre> <p>Slicing returns a sublist of the original list (up to the entire original list).</p> <p>The special thing about slicing is that none of the parameters are required. By selectively including thme we can do certain things, see below.</p>"},{"location":"Iterables/iterables.html#exercise-1","title":"Exercise 1\u00b6","text":"<p>~ 20 minutes</p>"},{"location":"Iterables/iterables.html#a-defining-a-list","title":"a. Defining a list\u00b6","text":"<p>Let's start with defining a list called <code>random_things</code> that is at least 4 elements long.  The data is completely up to you, but it must contain at least 1 <code>str</code> and 1 <code>float</code>.</p> <p>Use the <code>len</code> function to check if your list is indeed at least 4 elements long.</p>"},{"location":"Iterables/iterables.html#b-slicing","title":"b. Slicing\u00b6","text":"<p>Next, we should practice accessing elements in a list.</p>"},{"location":"Iterables/iterables.html#c-setting-values","title":"c. Setting values\u00b6","text":"<p>Here you have a list of names, but it contains a few spelling errors. Correct the entries in the list by accessing an element by its index and assigning a new string.</p> <pre><code>- Change \"Petre\" to \"Peter\"\n- Change \"Monika\" to \"Monica\"\n- Change \"george\" to \"George\" (capitalize it)\n</code></pre>"},{"location":"Iterables/iterables.html#lists-part-2","title":"Lists part 2\u00b6","text":""},{"location":"Iterables/iterables.html#nested-lists","title":"Nested Lists\u00b6","text":"<p>Lists can contain any kind of element, even other lists!</p>"},{"location":"Iterables/iterables.html#list-methods","title":"List Methods\u00b6","text":"<p>Working with lists is very common - here are a few things we can do!</p> <p>Adding elements to a list:</p> <ul> <li><code>append</code>: add an item to the end of the list.</li> <li><code>extend</code>: add to the end of a list all values passed to extend.</li> <li><code>insert</code>: insert an item at a given position.</li> </ul> <p>Note on append/extend: append is for adding single elements, extend for appending multiple elements from another iterable</p>"},{"location":"Iterables/iterables.html#exercise-2","title":"Exercise 2\u00b6","text":"<p>~15 minutes</p>"},{"location":"Iterables/iterables.html#sets","title":"Sets\u00b6","text":"<p>A set is a collection of unqiue, unordered, (unchangeable,) and unindexed elements.</p> <ul> <li>To create an empty set:<ul> <li>use curly brackets <code>{}</code>.</li> </ul> </li> <li>Unique elements: Each element in a set can only appear once.</li> <li>Unordered and unindexed elements: In a set, you cannot know in which order the elements might appear. Since the elements can appear in any order, they do not have an index and you therefore cannot access the elements of a set by an index.</li> <li>\"Unchangeable\" elements: You cannot change or update the elements of a set, but you can remove or add new items.</li> </ul>"},{"location":"Iterables/iterables.html#dictionaries","title":"Dictionaries\u00b6","text":"<p>A dictionary stores (key, value) pairs.</p> <ul> <li>Dictionaries are created with curly brackets <code>{key: value}</code></li> <li>Dictionaries are ordered by insertion order since <code>Python 3.5</code>.</li> <li>Dictionary values are accessed by keys.</li> <li>Each key in the dictionary is unique and duplicates are not allowed.</li> </ul>"},{"location":"Iterables/iterables.html#tuples","title":"Tuples\u00b6","text":"<p>A tuple is an (immutable) ordered container of values.</p> <ul> <li>To create a tuple, use round brackets <code>()</code>.</li> <li>\"Immutable\" means that the elements of a tuple can only be accessed, but not changed.</li> <li>Tuples can be used as keys in dictionaries and as elements of sets whereas lists cannot!</li> </ul>"},{"location":"Iterables/iterables.html#exercise-3","title":"Exercise 3\u00b6","text":"<p>~ 15 minutes</p>"},{"location":"Loops/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [Loops.ipynb](Loops.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Loops/Loops.ipynb) | Loops</p>"},{"location":"Loops/Loops.html","title":"4. Loops","text":"<p>Consider the code below: It prints the numbers 1 through 10 using what we've learned so far. This notebook is about how to do the same task less tediously. Loops are a way to repeatedly execute some code, in a simple and succinct way.</p> In\u00a0[\u00a0]: Copied! <pre>print(1)\nprint(2)\nprint(3)\nprint(4)\nprint(5)\nprint(6)\nprint(7)\nprint(8)\nprint(9)\nprint(10)\n</pre> print(1) print(2) print(3) print(4) print(5) print(6) print(7) print(8) print(9) print(10) <p>Indeed, we can use a for loop to do the same in only two lines:</p> <pre>#pseudo code\nfor number in number_list:\n    print number\n</pre> In\u00a0[\u00a0]: Copied! <pre>number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n#the variable number is initialized inside the for statement. \n#You do not need to declare it before. It will continue to exist after the loop.\nfor number in number_list:\n    print(number)\n    \nprint(\"Now we are done.\") \nprint(\"What is number now?\", number)\n</pre> number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  #the variable number is initialized inside the for statement.  #You do not need to declare it before. It will continue to exist after the loop. for number in number_list:     print(number)      print(\"Now we are done.\")  print(\"What is number now?\", number) <p>Loops are part of flow control. The code inside the loop is (usually) executed several times, whereas lines such as above are only executed one time. The program also needs to know when the loop is over and we return to 'linear' flow. Like in <code>if</code> blocks, this is made clear with indentation.</p> In\u00a0[\u00a0]: Copied! <pre>for number in range(1, 11):\n    print(number)\n</pre> for number in range(1, 11):     print(number) In\u00a0[\u00a0]: Copied! <pre>#try it out!\n</pre> #try it out!  <p>Another useful function for for loops is <code>enumerate</code>. It will create a list of tuples where the second element is the current item and the first element is its position:</p> In\u00a0[\u00a0]: Copied! <pre>#try it out!\ncountries = ['Denmark', 'Spain', 'Italy']\n\n# iterate over the ountries as we did with the list of numbers above:\nfor country in countries:\n    print(country)\n</pre> #try it out! countries = ['Denmark', 'Spain', 'Italy']  # iterate over the ountries as we did with the list of numbers above: for country in countries:     print(country)  In\u00a0[\u00a0]: Copied! <pre># get both items and their position\nfor index, country in enumerate(countries):\n    print(\"My number\" + str(index) + \" favorite country is: \" + country)\n</pre> # get both items and their position for index, country in enumerate(countries):     print(\"My number\" + str(index) + \" favorite country is: \" + country) <p>a. Use a for loop to iterate over <code>range(4)</code>. Which numbers does it produce?</p> In\u00a0[1]: Copied! <pre># your code goes here\n</pre> # your code goes here  <p>b. Now write a for loop using <code>range</code> that produces the numbers 1 to 4.</p> In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here <p>c. What numbers does the following range generate inside a for loop? Write out the loop to check.</p> <p><code>range(12,0,-3)</code></p> In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here <p>d. Loop through numbers 1-20:</p> <ul> <li>If the number is 4 or 13, print \"x is unlucky\"</li> <li>Otherwise:<ul> <li>If the number is even, print \"x is even\"</li> <li>If the number is odd, print \"x is odd\"</li> </ul> </li> </ul> <p>check <code>Conditions.ipynb</code></p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>e. In the code below we're counting from 0 as python usually does. Can you fix so that it starts writing from 1?</p> <pre># get both items and their position\nfor index, country in enumerate(countries):\n    print(\"My number\" + str(index) + \" favorite country is: \" + country)\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>my_float = 50.0\n\nwhile my_float &gt; 1:\n    my_float = my_float / 4\n    print(my_float)\n</pre> my_float = 50.0  while my_float &gt; 1:     my_float = my_float / 4     print(my_float) In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here <p>b. What does the following loop do?</p> <pre>i = 0\n    while i &lt;= 5:\n        i = i + 1\n        print(i)\n</pre> In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here <p>c. Fix the infinite loop below so that it doesn't run endlessly anymore:</p> <pre># this code runs forever...\n    x = 0\n    while x != 11:\n        x += 2\n        print(x)\n</pre> In\u00a0[\u00a0]: Copied! <pre># your code goes here\n</pre> # your code goes here <p>The <code>break</code> statement needs to be within the block of code under your loop statement, ususally after a conditional <code>if</code> statement.</p> In\u00a0[\u00a0]: Copied! <pre>for letter in 'Python':\n    if letter == 'h':\n        break\n    print('Current Letter :', letter)\n</pre> for letter in 'Python':     if letter == 'h':         break     print('Current Letter :', letter) <p>The difference in using <code>continue</code> rather than <code>break</code> is that the loop will continue despite the disruption when the condition is met.</p> In\u00a0[\u00a0]: Copied! <pre>for letter in 'Python':\n    if letter == 'h':\n        continue\n    print('Current Letter :', letter)\n</pre> for letter in 'Python':     if letter == 'h':         continue     print('Current Letter :', letter) In\u00a0[\u00a0]: Copied! <pre>for letter in 'Python':\n    if letter == 'h':\n        pass\n    print('Current Letter :', letter)\n</pre> for letter in 'Python':     if letter == 'h':         pass     print('Current Letter :', letter) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Loops/Loops.html#loops","title":"Loops\u00b6","text":""},{"location":"Loops/Loops.html#for-loops","title":"<code>for</code> loops\u00b6","text":"<p>In Python, <code>for</code> loops are written like this:</p> <pre>for variable in sequence:\n    this code is executed inside the loop\n    and this code too\n\nnow we are not in the loop anymore\n</pre> <p>Read: for each *variable* in *sequence, execute the expression* (that is code you want to repeat for each variable)</p> <ul> <li><p><code>variable</code> is a variable and can be called whatever you want.</p> </li> <li><p><code>sequence</code> is a sequence we iterate over. It is some kind of collection of items, for instance: a <code>str</code> of characters, a <code>range</code>, a list etc.</p> </li> <li><p><code>variable</code> references the current position of our *iterator* within the iterable variable. It will iterate over (run through) every item of the collection and then go away when it has visited all items.</p> </li> <li><p>The body of the loop is indented.</p> </li> <li><p>When we write a command on the same indentation level as the <code>for</code> statement the loop is over. This will be executed after the loop.</p> </li> </ul>"},{"location":"Loops/Loops.html#for-loops-with-ranges","title":"<code>for</code> loops with ranges\u00b6","text":"<p>Instead of writing out a list with numerical value we can create it using a range:</p>"},{"location":"Loops/Loops.html#range-function","title":"<code>range()</code> function\u00b6","text":"<p>The <code>range()</code> function returns a sequence of numbers, starting from 0 by default, and increments by 1 by default, and stops at a specified number (which is not included in the range).</p> <p>Based on what we learned so far you might think that it creates a list, but it does not. In fact, range does not do anything by itself, but can be used inside a for loop to create the sequence to loop over.</p> <p>The syntax is: <code>range(start, stop, step)</code></p> <p>The step parameter tells the function how many steps to skip and which direction to count (<code>+</code> for up and <code>-</code> for down).</p> <p>Examples:</p> <ul> <li><p><code>range(8)</code> gives you integers from 0 through 7.</p> </li> <li><p><code>range(2, 9)</code> will give you integers from 2 to 8.</p> </li> <li><p><code>range(10, 20, 2)</code>  will give you even numbers from 10 to 18. Remember, the upper limit of the range is excluded!</p> </li> <li><p><code>range(9, 0, -1)</code>  will start from 9 and give you integers down to 1.</p> </li> </ul>"},{"location":"Loops/Loops.html#exercise-1","title":"Exercise 1\u00b6","text":"<p>~ 20 minutes</p>"},{"location":"Loops/Loops.html#while-loops","title":"<code>while</code> loops\u00b6","text":"<p>We can also iterate over a sequence using a <code>while</code> loop, which has a different format:</p> <pre>while condition:\n    expression\n</pre> <p><code>while</code> loops continue to execute while a certain condition is <code>True</code>, and will end when it becomes <code>False</code>.</p> <pre>user_response = \"Something...\"\nwhile user_response != \"please\":\n    user_response = input(\"Ah ah ah, you didn't say the magic word: \")\n</pre> <p><code>while</code> loops require more careful setup than <code>for</code> loops, since you have to specify the termination conditions manually.</p> <p>Be careful! If the condition doesn't become <code>False</code> at some point, your loop will continue *forever*!</p>"},{"location":"Loops/Loops.html#exercise-2","title":"Exercise 2\u00b6","text":"<p>~15 minutes</p> <p>a. What does the following loop do?</p> <pre>i = 1\n    while i &lt; 5:\n        i + i\n        print(i)\n</pre> <p>Hint: is the value of <code>i</code> changing?</p>"},{"location":"Loops/Loops.html#python-loop-control","title":"Python loop control\u00b6","text":"<p>Controlled exit, skipping a block of code, or ignoring external factors that might influence your code, can be achieved with the Python statements: <code>break</code>, <code>continue</code>, and <code>pass</code>.</p>"},{"location":"Loops/Loops.html#break-statement","title":"*<code>break</code>* statement\u00b6","text":"<p>The keyword <code>break</code> gives us the ability to exit out of a loop whenever we want, and can be used in both <code>while</code> and <code>for</code> loops.</p> <p>Example:</p> <pre>for letter in 'Python':\n    if letter == 'h':\n        break\n    print('Current Letter:', letter)\n</pre>"},{"location":"Loops/Loops.html#continue-statement","title":"*<code>continue</code>* statement\u00b6","text":"<p>The <code>continue</code> statement in Python gives you the option to skip over the part of a loop where a condition is met, but to go on to complete the rest of the loop. That is, it disrupts the iteration of the loop that fulfills the condition and returns the control to the beginning of the loop. It works with both <code>while</code> and <code>for</code> loops.</p> <p>Example:</p> <pre>for letter in 'Python':\n    if letter == 'h':\n        continue\n    print('Current Letter :', letter)\n</pre>"},{"location":"Loops/Loops.html#pass-statement","title":"*<code>pass</code>* statement\u00b6","text":"<p>The <code>pass</code> statement is used when a statement is required syntactically but you do not want any command or code to execute. It's a null operation.</p> <p>Example:</p> <pre>for letter in 'Python':\n    if letter == 'h':\n        pass\n    print('Current Letter :', letter)\n</pre>"},{"location":"Loops/Loops.html#exercise","title":"Exercise\u00b6","text":"<p>~ 15 minutes</p> <p>Write a loop that:</p> <ul> <li>iterates over each character in the string <code>\"I live in CPH, and I like it here.\"</code>;</li> <li>for each character checks if it is a space;</li> <li>if it is a space, then just continue with the loop;</li> <li>if the character is not a space, do the following:</li> <li>check if it is a comma <code>,</code> ;</li> <li>if the character is a comma <code>,</code>, break the loop;</li> <li>if the character is not a comma, print it.</li> </ul>"},{"location":"Pandas/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [Pandas.ipynb](Pandas.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/march_2023/Pandas/Pandas.ipynb) | Pandas [IO_Pandas.ipynb](IO_Pandas.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/march_2023/Pandas/IO_Pandas.ipynb) | Reading data with Pandas   ## Description  - introduce the two main objects `Series` and `DataFrame` - highlight the concept of an `Index`, naming rows and columns (ToDo: add names to Series example in the beginning).  ## Ressources  - [Pandas Tutorial for Hands on ML](https://nbviewer.jupyter.org/github/ageron/handson-ml2/blob/master/tools_pandas.ipynb)</p>"},{"location":"Pandas/Pandas.html","title":"5. Pandas","text":"In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd In\u00a0[\u00a0]: Copied! <pre>series_list = pd.Series([3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\nseries_list\n</pre> series_list = pd.Series([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) series_list In\u00a0[\u00a0]: Copied! <pre>series_range = pd.Series(range(3, 13))\nseries_range\n</pre> series_range = pd.Series(range(3, 13)) series_range In\u00a0[\u00a0]: Copied! <pre>print(\"Series from list, underlying data:\\t\", series_list.values)\nprint(\"Series from range, underlying data:\\t\", series_range.values)\n</pre> print(\"Series from list, underlying data:\\t\", series_list.values) print(\"Series from range, underlying data:\\t\", series_range.values) In\u00a0[\u00a0]: Copied! <pre>series_list.values\n</pre> series_list.values In\u00a0[\u00a0]: Copied! <pre>series_range.values\n</pre> series_range.values In\u00a0[\u00a0]: Copied! <pre>series1 = pd.Series([1,2,3], index=['row1', 'row2', 'row3'])\nseries1\n</pre> series1 = pd.Series([1,2,3], index=['row1', 'row2', 'row3']) series1 In\u00a0[\u00a0]: Copied! <pre>series2 = pd.Series([1,2,4])\nseries2.index = ['row1', 'row2', 'row4']\nseries2\n</pre> series2 = pd.Series([1,2,4]) series2.index = ['row1', 'row2', 'row4'] series2 In\u00a0[\u00a0]: Copied! <pre>series1 + series2\n</pre> series1 + series2 <p>A DataFrame is basically, a Table of data (or a tabular data structure) with labeled rows and columns. The rows are labeled by a special data structure called an Index, that permits fast look-up and powerful relational operations.</p> <p></p>  From https://www.geeksforgeeks.org/  In\u00a0[\u00a0]: Copied! <pre>data = [\n    [2.23, 1, \"test\"],\n    [3.45, 2, \"train\"],\n    [4.5, 3, \"test\"],\n    [6.0, 4, \"train\"]\n]\n\ndf = pd.DataFrame(data, columns=['A', 'B', 'C'])\ndf\n</pre> data = [     [2.23, 1, \"test\"],     [3.45, 2, \"train\"],     [4.5, 3, \"test\"],     [6.0, 4, \"train\"] ]  df = pd.DataFrame(data, columns=['A', 'B', 'C']) df In\u00a0[\u00a0]: Copied! <pre>data = [\n    {'A': 2.23, 'B': 1, 'C': \"test\"},\n    {'A': 3.45, 'B': 2, 'C': \"train\"},\n    {'A': 4.5, 'B': 3, 'C': \"test\"},\n    {'A': 6.0, 'B': 4, 'C': \"train\"}\n]\n\ndf = pd.DataFrame(data)\ndf\n</pre> data = [     {'A': 2.23, 'B': 1, 'C': \"test\"},     {'A': 3.45, 'B': 2, 'C': \"train\"},     {'A': 4.5, 'B': 3, 'C': \"test\"},     {'A': 6.0, 'B': 4, 'C': \"train\"} ]  df = pd.DataFrame(data) df In\u00a0[\u00a0]: Copied! <pre>data = {\n    \"A\": [2.23, 3.45, 4.5, 6.0],\n    \"B\": [1, 2, 3, 4],\n    \"C\": [\"test\", \"train\", \"test\", \"train\"],\n}\n\ndf = pd.DataFrame(data)\ndf\n</pre> data = {     \"A\": [2.23, 3.45, 4.5, 6.0],     \"B\": [1, 2, 3, 4],     \"C\": [\"test\", \"train\", \"test\", \"train\"], }  df = pd.DataFrame(data) df In\u00a0[\u00a0]: Copied! <pre>data = {\n    \"row1\": {\"A\": 2.23, \"B\": 1, \"C\": \"test\"},\n    \"row3\": {\"A\": 3.45, \"B\": 2, \"C\": \"train\"},\n    \"row2\": {\"A\": 4.5, \"B\": 3, \"C\": \"test\"},\n    \"row4\": {\"A\": 6.0, \"B\": 4, \"C\": \"train\"},\n}\n\ndf = pd.DataFrame.from_dict(\n    data,\n    orient=\"index\",  # default is columns. pd.DataFrame also works, but you have to transpose the data\n)\ndf\n</pre> data = {     \"row1\": {\"A\": 2.23, \"B\": 1, \"C\": \"test\"},     \"row3\": {\"A\": 3.45, \"B\": 2, \"C\": \"train\"},     \"row2\": {\"A\": 4.5, \"B\": 3, \"C\": \"test\"},     \"row4\": {\"A\": 6.0, \"B\": 4, \"C\": \"train\"}, }  df = pd.DataFrame.from_dict(     data,     orient=\"index\",  # default is columns. pd.DataFrame also works, but you have to transpose the data ) df In\u00a0[\u00a0]: Copied! <pre>df = pd.DataFrame()\ndf['A'] = [2.23, 3.45, 4.5, 6.0]\ndf['B'] = [1, 2, 3, 4]\ndf['C'] = [\"test\", \"train\", \"test\", \"train\"]\n\ndf\n</pre> df = pd.DataFrame() df['A'] = [2.23, 3.45, 4.5, 6.0] df['B'] = [1, 2, 3, 4] df['C'] = [\"test\", \"train\", \"test\", \"train\"]  df In\u00a0[\u00a0]: Copied! <pre>data = [\n    [2.23, 1, \"test\"],\n    [3.45, 2, \"train\"],\n    [4.5, 3, \"test\"],\n    [6.0, 4, \"train\"]\n]\n\ndf = pd.DataFrame(data, index=['row1', 'row2', 'row3', 'row4'], columns=['A', 'B', 'C'])\ndf\n</pre> data = [     [2.23, 1, \"test\"],     [3.45, 2, \"train\"],     [4.5, 3, \"test\"],     [6.0, 4, \"train\"] ]  df = pd.DataFrame(data, index=['row1', 'row2', 'row3', 'row4'], columns=['A', 'B', 'C']) df In\u00a0[\u00a0]: Copied! <pre>df.index = ['a', 'b', 'c', 'd']\ndf\n</pre> df.index = ['a', 'b', 'c', 'd'] df In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Which approach did you prefer? Why?</p> In\u00a0[\u00a0]: Copied! <pre>url_ecdc_daily_cases = \"https://opendata.ecdc.europa.eu/covid19/nationalcasedeath_eueea_daily_ei/csv/data.csv\"\ndf = pd.read_csv(url_ecdc_daily_cases)\ndf\n</pre> url_ecdc_daily_cases = \"https://opendata.ecdc.europa.eu/covid19/nationalcasedeath_eueea_daily_ei/csv/data.csv\" df = pd.read_csv(url_ecdc_daily_cases) df In\u00a0[\u00a0]: Copied! <pre>df.shape\n</pre> df.shape In\u00a0[\u00a0]: Copied! <pre>df.dtypes\n</pre> df.dtypes In\u00a0[\u00a0]: Copied! <pre>df.index\n</pre> df.index In\u00a0[\u00a0]: Copied! <pre>df.columns\n</pre> df.columns In\u00a0[\u00a0]: Copied! <pre>df.head()\n</pre> df.head() In\u00a0[\u00a0]: Copied! <pre>df.tail()\n</pre> df.tail() In\u00a0[\u00a0]: Copied! <pre>df.sample(15)\n</pre> df.sample(15) In\u00a0[\u00a0]: Copied! <pre>df.info(memory_usage='deep')\n</pre> df.info(memory_usage='deep') In\u00a0[\u00a0]: Copied! <pre>_ = df.info()\n</pre> _ = df.info()  In\u00a0[\u00a0]: Copied! <pre>print(_)\n</pre> print(_) In\u00a0[\u00a0]: Copied! <pre>rename_df = df.rename(columns={'day':'Column day', 'deaths':'Column deaths'}, index={0:'row1', 1:'row2', 100:'end row'})\nrename_df.head()\n</pre> rename_df = df.rename(columns={'day':'Column day', 'deaths':'Column deaths'}, index={0:'row1', 1:'row2', 100:'end row'}) rename_df.head() In\u00a0[\u00a0]: Copied! <pre>df['day']\n</pre> df['day'] In\u00a0[\u00a0]: Copied! <pre>df[['year', 'month', 'day']]\n</pre> df[['year', 'month', 'day']] In\u00a0[\u00a0]: Copied! <pre>df['day'][0]\n</pre> df['day'][0] <p>Select an entire column:</p> In\u00a0[\u00a0]: Copied! <pre>df.iloc[:, 5]   # all rows, and 6th column\n</pre> df.iloc[:, 5]   # all rows, and 6th column <p>Select the first 3 rows of the 6th column:</p> In\u00a0[\u00a0]: Copied! <pre>df.iloc[:3, 5]\n</pre> df.iloc[:3, 5] <p>Select only the second and third rows:</p> In\u00a0[\u00a0]: Copied! <pre>df.iloc[1:3, 5]\n</pre> df.iloc[1:3, 5] <p>Select with a list:</p> In\u00a0[\u00a0]: Copied! <pre>df.iloc[[2, 3, 4, 5], 5]\n</pre> df.iloc[[2, 3, 4, 5], 5] <p>Use negative numbers:</p> In\u00a0[\u00a0]: Copied! <pre>df.iloc[-5:]\n</pre> df.iloc[-5:] In\u00a0[\u00a0]: Copied! <pre>df.loc[:, 'deaths']\n</pre> df.loc[:, 'deaths'] In\u00a0[\u00a0]: Copied! <pre>df.loc[:2, 'deaths']\n</pre> df.loc[:2, 'deaths'] In\u00a0[\u00a0]: Copied! <pre>df.loc[1:2, 'deaths']\n</pre> df.loc[1:2, 'deaths'] In\u00a0[\u00a0]: Copied! <pre>df.loc[[2, 3, 4, 5], 'deaths']\n</pre> df.loc[[2, 3, 4, 5], 'deaths'] In\u00a0[\u00a0]: Copied! <pre>df.loc[22828:,['dateRep', 'cases', 'deaths', 'countriesAndTerritories']]\n</pre> df.loc[22828:,['dateRep', 'cases', 'deaths', 'countriesAndTerritories']] <p>In small DataFrames:</p> <pre>df = pd.DataFrame(data, index=['row1', 'row2', 'row3', 'row4'], columns=['A', 'B', 'C'])\n</pre> <p>or</p> <pre>df.index = ['row1', 'row2', 'row3', 'row4']\n</pre> <p>But in big DataFrames there are too many rows to make the above efficient. So we use <code>set_index()</code>:</p> <pre>df.set_index('Column1')\n</pre> <p>To keep the index change, store it as a variable:</p> <pre>df = df.set_index('Column1')\n</pre> <p>or use the argument <code>inplace=True</code>:</p> <pre>df.set_index('Column1', inplace=True)\n</pre> In\u00a0[\u00a0]: Copied! <pre>new_df = df.set_index('countriesAndTerritories')\nnew_df.head()\n</pre> new_df = df.set_index('countriesAndTerritories') new_df.head() In\u00a0[\u00a0]: Copied! <pre>new_df.loc['Denmark']\n</pre> new_df.loc['Denmark'] <p>Display the first 5 lines of the dataset.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Show the last 15 lines</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Check 10 random lines of the dataset</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Make a new dataframe containing just the date, population data and number of cases and deaths</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Make a new dataframe containing just the 10th, 15th and 16th lines of the dataset. Which method did you use? Why?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>You can also filter based on multiple conditions, using the element-wise (\"bit-wise\") logical operators <code>&amp;</code> data intersection, or <code>|</code> for the data union.</p> <pre>select_rows = df[(df['Column1'] &gt; 0) &amp; (df['Column2'] &gt; 2)]\n</pre> <p>or</p> <pre>select_rows = df.loc[(df['Column1'] &gt; 0) &amp; (df['Column2'] &gt; 2)]\n</pre> <pre>select_rows = df[(df['Column1'] &gt; 0) | (df['Column2'] &gt; 2)]\n</pre> <p>or</p> <pre>select_rows = df.loc[(df['Column1'] &gt; 0) | (df['Column2'] &gt; 2)]\n</pre> <p>Consider  first creating the mask (<code>Series</code> of <code>True</code> and <code>False</code> values indicating if a row is selected)</p> <pre>mask = (df['Column1'] &gt; 0) | (df['Column2'] &gt; 2)\nselect_rows = df[mask]\n</pre> <p>Using masks:</p> <pre>row_mask = (df['Column1'] &gt; 0) | (df['Column2'] &gt; 2)\ncolumn_mask = ['Column4', 'Column5']\n\nselect_df = df.loc[row_mask, column_mask]\n</pre> <p>Checkout more interesting methods:</p> <ul> <li><code>pandas.Series.isin</code></li> <li><code>pandas.Series.betweeen</code></li> <li><code>pandas.DataFrame.notnull</code></li> <li><code>pandas.DataFrame.isnull</code></li> </ul> In\u00a0[\u00a0]: Copied! <pre>df.loc[df['countriesAndTerritories'] == 'Denmark'] # This is not saved\n</pre> df.loc[df['countriesAndTerritories'] == 'Denmark'] # This is not saved In\u00a0[\u00a0]: Copied! <pre>filtered_df = df.loc[df['countriesAndTerritories']=='Denmark', ['dateRep', 'cases']]\nfiltered_df.head()\n</pre> filtered_df = df.loc[df['countriesAndTerritories']=='Denmark', ['dateRep', 'cases']] filtered_df.head() In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>With what you learned so far, how would you calculate the daily deaths, on average, for Austria?</p> <p>We will solve together</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df.mean()  # uses numeric column only\n</pre> df.mean()  # uses numeric column only In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>How many countries does europe have?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>How many unique dates are in this data set?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>What is the average daily deaths for Norway?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre># Create new column based on the number of cases per 100.000 population\ndf['cases_per_100k'] = df['cases'] / df['popData2020'] * 100000\n\n# Filter dataset to include only Denmark\nmask_denmark = df['countriesAndTerritories'] == 'Denmark'\ndf[mask_denmark]\n</pre> # Create new column based on the number of cases per 100.000 population df['cases_per_100k'] = df['cases'] / df['popData2020'] * 100000  # Filter dataset to include only Denmark mask_denmark = df['countriesAndTerritories'] == 'Denmark' df[mask_denmark] <p>For more complicated operations, where you want to combine <code>DataFrame</code>s with <code>Series</code>, you can have a look how broadcasting works in pandas.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Which country, and on what date, had the lowest number of infected in Europe?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Make the country code variable column lower-cased</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Make a column called \"alive\", to be the opposite of the deaths column</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df.groupby(by='countriesAndTerritories').cases.sum().loc['Denmark']\n</pre> df.groupby(by='countriesAndTerritories').cases.sum().loc['Denmark'] In\u00a0[\u00a0]: Copied! <pre>df.loc[mask_denmark, 'cases'].sum()\n</pre> df.loc[mask_denmark, 'cases'].sum() <p>What was the median number of daily cases per country?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>How many days where there without deaths in each country?</p> <ul> <li>select rows with zero deaths, group these and count the days</li> </ul> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>How many infected daily on average for each country in each month?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>What was the infection rate for each country for the whole period?</p> <p>For the purposes of this exercise, consider infection rate is the total number of infected divided by the population size.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>new_df = df.groupby(by='countriesAndTerritories').agg({'cases': 'sum', 'popData2020': 'mean'})\nnew_df['cases']/new_df['popData2020']\n</pre> new_df = df.groupby(by='countriesAndTerritories').agg({'cases': 'sum', 'popData2020': 'mean'}) new_df['cases']/new_df['popData2020'] In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>What was the highest and the lowest number of infected per month, per country?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df.sort_values('cases_per_100k', ascending=False)\n</pre> df.sort_values('cases_per_100k', ascending=False) In\u00a0[\u00a0]: Copied! <pre>url = 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/titanic.csv'\ntitanic = pd.read_csv(url)\ntitanic\n</pre> url = 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/titanic.csv' titanic = pd.read_csv(url) titanic <p>What proportion of the \"deck\" column is missing data?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>How many rows don't contain any missing data at all?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Make a dataframe with only the rows containing no missing data.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>data = pd.DataFrame({'time': [0.5, 1., 1.5, None, 2.5, 3., 3.5, None], 'value': [\n                    6, 4, 5, 8, None, 10, 11, None]})\ndata\n</pre> data = pd.DataFrame({'time': [0.5, 1., 1.5, None, 2.5, 3., 3.5, None], 'value': [                     6, 4, 5, 8, None, 10, 11, None]}) data <p>Replace all the missing \"value\" rows with zeros.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Replace the missing \"time\" rows with the previous value.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Replace all of the missing values with the data from the next row. What do you notice when you do this with this dataset?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Linearly interpolate the missing data. What is the result for this dataset?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p><code>lambda</code> functions are especially useful when combined with mapping methods like <code>map()</code> and <code>apply()</code>.</p> <p>The map term indicates a function that takes one set of values and \"maps\" them to another set of values. In data science, we often need to create new representations or transform existing data. mapping functions help us do this work.</p> <p><code>map()</code> is slightly simpler and takes in a function as argument, for example, a <code>lambda</code> function. Whatever function you pass though, make sure the expexted input is always a single value. The return of <code>map()</code> will be the original input value, transformed by the <code>lambda</code> function.</p> <pre>average_cases = df.cases.mean()\n\ndf.cases.map(lambda x: x - average_cases)  # Centers the data distribution of number of cases around 0.\n</pre> <p>Besides functions, <code>map()</code> can also accept dictionaries (key corresponds to input value, and dictionary value is the new value to replace the input one), and Series.</p> <p><code>apply()</code> is the equivalent method but when we want to transform an entire DataFrame. It can be applied row-wise or column-wise, depending whether the argument <code>axis</code> is set to <code>rows</code> or <code>columns</code>, respectively.</p> <pre>average_cases = df.cases.mean()\n\ndef center_mean(data):\n    data.cases = data.cases - average_cases\n    return data\n\ndf.apply(center_mean, axis='columns')\n</pre> <p>Differently from <code>map()</code>, <code>apply()</code> also allows passing of positional or keyword arguments to the function.</p> <pre>def get_deaths_class(value, lower_threshold, upper_threshold):\n    if value &gt;= int(upper_threshold):\n        class_name = 'High'\n    elif value &lt;= int(lower_threshold):\n        class_name = 'Low'\n    else:\n        class_name = 'Moderate'\n\n    return class_name\n\ndf['deaths_class'] = df['deaths'].apply(get_deaths_class, lower_threshold = 20, upper_threshold = 100)\n</pre> <p>You can also use the <code>apply()</code> method in a group-wise analysis:</p> <pre>df.groupby(['countriesAndTerritories', 'year', 'month']).apply(lambda df: df.loc[df.cases.idxmax()])\n</pre> <p>For more information of these methods and more, go to Pandas API reference</p> <p><code>merge()</code> and <code>join()</code> can do similar operations, but <code>join()</code> is often easier to apply. These are used when DataFrames hold different kinds of information about the same entity, linked by some common feature.</p> <p>To combine on the common column, use the argument <code>on</code> and set it to the common column name:</p> <pre>data3 = {'id': ['1', '2', '3', '4', '5', '7', '8', '9', '10', '11'],\n         'Feature3': [12, 13, 14, 15, 16, 17, 15, 12, 13, 23]}\ndf3 = pd.DataFrame(data3, columns = ['id', 'Feature3'])\n\nmerger_df = pd.merge(combined_df_rows, df3, on='id')\n</pre> <p>Sometimes, the column on which you want to merge has different names. If that is the case, you can specify the arguments <code>left_on</code> and <code>right_on</code> for the left DataFrame and right DataFrame column names, respectively:</p> <pre>data3 = {'identifier': ['1', '2', '3', '4', '5', '7', '8', '9', '10', '11'],\n         'Feature3': [12, 13, 14, 15, 16, 17, 15, 12, 13, 23]}\ndf3 = pd.DataFrame(data3, columns = ['identifier', 'Feature3'])\n\nmerger_df = pd.merge(combined_df_rows, df3, left_on='id', right_on='identifier')\n</pre> <p>At the same time, you can also decide what kind of join logics you want to use:</p> <ul> <li>Full outer join: <code>how = outer</code></li> <li>Inner join: <code>how = inner</code></li> <li>Right join: <code>how = right</code></li> <li>Left join: <code>how = left</code></li> </ul> <p>For more information and an easy to visualize guide for these methods, please check this link this link.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>url = 'https://raw.githubusercontent.com/Center-for-Health-Data-Science/PythonTsunami/fall2021/data/depths.csv'\ndepths = pd.read_csv(url)\ndepths\n</pre> url = 'https://raw.githubusercontent.com/Center-for-Health-Data-Science/PythonTsunami/fall2021/data/depths.csv' depths = pd.read_csv(url) depths In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Pandas/Pandas.html#pandas","title":"Pandas\u00b6","text":"<p>Pandas cheat sheet</p>"},{"location":"Pandas/Pandas.html#introduction","title":"Introduction\u00b6","text":"<p>Popular package for data science: offers powerful data structures that make data manipulation and analysis easy.</p> <p>The <code>DataFrame</code> is one of them.</p> <p>Pandas is built on top of <code>numpy</code>.</p> <p>Pandas is well suited for tabular data with heterogeneously-typed columns, as in an Excel spreadsheet</p> <p>Has an interface to directly plot using <code>maptlotlib</code>, <code>seaborn</code>, <code>plotly</code>, for example.</p>"},{"location":"Pandas/Pandas.html#two-main-classes-types-objects","title":"Two main classes (types/ objects)\u00b6","text":"<ol> <li><code>pandas.Series</code></li> <li><code>pandas.DataFrame</code></li> </ol> <ul> <li>a <code>Series</code> is a <code>numpy.array</code> with an <code>Index</code> series.</li> <li>a column in a <code>DataFrame</code> is a <code>Series</code>.</li> <li>columns in a <code>DataFrame</code> share an <code>Index</code></li> </ul>"},{"location":"Pandas/Pandas.html#import-relevant-packages","title":"Import relevant packages\u00b6","text":""},{"location":"Pandas/Pandas.html#creating-an-instance-of-a-pandasseries","title":"Creating an instance of a <code>pandas.Series</code>\u00b6","text":"<p>There are many ways. E.g from a list, a built-in <code>range</code> and <code>numpy</code> arrays.</p> <p>But a Series is an object holding some data.</p> <p>Let's create a Series from a list and a built-in <code>range</code>.</p>"},{"location":"Pandas/Pandas.html#difference-indexing-of-data","title":"Difference: indexing of data\u00b6","text":"<ul> <li>pandas names \"data\" by an row indices (and column indices for 2D structures)</li> <li>see also recent talk on PyData2021 by James Powell (it's relatively fast)</li> </ul>"},{"location":"Pandas/Pandas.html#what-is-a-dataframe","title":"What is a DataFrame?\u00b6","text":""},{"location":"Pandas/Pandas.html#create-a-dataframe-directly","title":"Create a DataFrame directly\u00b6","text":""},{"location":"Pandas/Pandas.html#from-a-list-of-lists","title":"From a <code>list</code> of <code>list</code>s\u00b6","text":""},{"location":"Pandas/Pandas.html#from-a-list-of-dicts","title":"From a <code>list</code> of <code>dict</code>s\u00b6","text":""},{"location":"Pandas/Pandas.html#from-a-dict-of-lists","title":"From a Dict of Lists\u00b6","text":""},{"location":"Pandas/Pandas.html#from-a-dict-of-dicts","title":"From a <code>dict</code> of <code>dict</code>s\u00b6","text":""},{"location":"Pandas/Pandas.html#from-an-empty-dataframe","title":"From an empty <code>DataFrame</code>\u00b6","text":""},{"location":"Pandas/Pandas.html#indexing-of-data","title":"Indexing of data\u00b6","text":""},{"location":"Pandas/Pandas.html#exercise-1","title":"Exercise 1\u00b6","text":"<p>Please recreate the table below as a Dataframe using one of the approaches detailed above:</p> Year Product Cost 0 2015 Apples 0.35 1 2016 Apples 0.45 2 2015 Bananas 0.75 3 2016 Bananas 1.10"},{"location":"Pandas/Pandas.html#loading-data-into-dataframes-from-a-file","title":"Loading data into <code>DataFrame</code>s from a file\u00b6","text":"<p>Pandas has functions that can make DataFrames from a wide variety of file types.  To do this, use one of the functions in Pandas that start with <code>read_</code>.  Here is a non-exclusive list of examples:</p> File Type Function Name Excel <code>pd.read_excel</code> CSV, TSV <code>pd.read_csv</code> H5, HDF, HDF5 <code>pd.read_hdf</code> JSON <code>pd.read_json</code> SQL <code>pd.read_sql_table</code> <p>These are all functions, which can be called, i.e. <code>pd.read_csv()</code></p>"},{"location":"Pandas/Pandas.html#loading-the-data","title":"Loading the Data\u00b6","text":"<p>The file can be local or hosted: The <code>read_*</code>-function have many options and are very high general (in the sense of broad or comprehensive) functions.</p>"},{"location":"Pandas/Pandas.html#examining-the-dataset","title":"Examining the Dataset\u00b6","text":"<p>Sometimes, we might just want to quickly inspect the DataFrame:</p>"},{"location":"Pandas/Pandas.html#attributes","title":"Attributes\u00b6","text":"<pre>df.shape    # Shape of the object (2D)\ndf.dtypes   # Data types in each column\ndf.index    # Index range\ndf.columns  # Column names\n</pre>"},{"location":"Pandas/Pandas.html#functions","title":"Functions\u00b6","text":"<pre>df.head()       # Displays first 5 rows\ndf.tail()       # Displays last 5 rows\ndf.sample()     # Displays randow 5 rows\ndf.info()       # DataFrame information\n</pre>"},{"location":"Pandas/Pandas.html#shape","title":"Shape\u00b6","text":"<p>The first dimension are the number of rows (the <code>len</code>gth of the <code>DataFrame</code>), the second dimension the number of features or columns. The direction going down the rows is <code>axis=0</code> or <code>axis='index'</code>, and going over the columns is <code>axis=1</code> or <code>axis='columns'</code>.</p> axis descriptions 0 index 1 columns"},{"location":"Pandas/Pandas.html#data-types","title":"Data types\u00b6","text":""},{"location":"Pandas/Pandas.html#index-and-columns","title":"Index and Columns\u00b6","text":""},{"location":"Pandas/Pandas.html#head-tail-and-sample","title":"Head, tail and sample\u00b6","text":""},{"location":"Pandas/Pandas.html#info","title":"Info\u00b6","text":""},{"location":"Pandas/Pandas.html#renaming-indexcolumn-names","title":"Renaming index/column names\u00b6","text":"<p>Data might come to us with index names, column names or othe naming conventions that do not fit our requirements.</p> <p>You can change those names to something more fitting, using the <code>rename()</code> function.</p> <p>If you want to change index names and/or column names, use the keyword <code>index</code> or <code>columns</code>, respectively, and pass a dictionary with the original index/column name as key, and the new name as value.</p> <pre>df.rename(columns={'A':'Column A', 'D':'Column D'})\n\ndf.rename(index={0:'row1', 1:'row2', 100:'end row'})\n</pre> <p>You can also pass functions to <code>rename()</code>:</p> <pre>df.rename(index=str)           # Change the index data type to string\n\ndf.rename(columns=str.lower)   # Make all column names lowercase\n</pre> <p>To keep the changes, set the <code>inplace</code> argument to <code>True</code>, or store the changed DataFrame in a variable:</p> <pre>df.rename(index=str, inplace=True)\n\nnew_df = df.rename(index=str)\n</pre>"},{"location":"Pandas/Pandas.html#indexing-and-selecting-data","title":"Indexing and Selecting Data\u00b6","text":""},{"location":"Pandas/Pandas.html#native-accessors","title":"Native accessors\u00b6","text":"<p>Pandas has a lot of flexibility in the number of syntaxes it supports.  For example, to select columns in a DataFrame:</p> <pre>df['Column1']\ndf.Column1  # no whitespaces possible!\n</pre> <p>Multiple Columns can also be selected by providing a list:</p> <pre>df[['Column1', 'Column2']]\n</pre>"},{"location":"Pandas/Pandas.html#pandas-accessors","title":"Pandas accessors\u00b6","text":"<p>Accessor operators  iloc (index-based) and loc (label-based):</p> <pre>df.iloc[5]     # df.iloc[row_index, column_index]\ndf.loc['Row6']   # df.loc[row_label, column_label]\n</pre> <p>On its own, the \":\" operator means \"everything\".</p> <p>When combined with other selectors, can be used to indicate a range of values.</p> <p>In loc, both start bound and the stop bound are inclusive, while in iloc, the stop bound is exclusive.</p> <p></p>  From https://towardsdatascience.com/loc-vs-iloc-in-pandas-heres-the-difference-\u201416cd4bcbecab"},{"location":"Pandas/Pandas.html#index-based-selection","title":"Index-based selection\u00b6","text":""},{"location":"Pandas/Pandas.html#label-based-selection","title":"Label-based selection\u00b6","text":""},{"location":"Pandas/Pandas.html#modifying-the-index","title":"Modifying the index\u00b6","text":""},{"location":"Pandas/Pandas.html#exercise-2","title":"Exercise 2\u00b6","text":""},{"location":"Pandas/Pandas.html#conditional-selection","title":"Conditional selection\u00b6","text":""},{"location":"Pandas/Pandas.html#row-selection","title":"Row selection\u00b6","text":"<p>Defining a condition with a Pandas DataFrame follows the same syntax:</p> <pre>df['Column1'] &gt; 0   # Return a Series of True and False\n</pre> <p>To filter the DataFrame for the rows where the value is <code>True</code>:</p> <pre>select_rows = df[df['Column1'] &gt; 0]\n</pre> <p>or</p> <pre>select_rows = df.loc[df['Column1'] &gt; 0]\n</pre>"},{"location":"Pandas/Pandas.html#row-and-column-selection","title":"Row and Column selection\u00b6","text":"<pre>select_df = df.loc[df['Column1'] &gt; 0, ['Column1', 'Column2', 'Column3']]\n</pre> <p>or</p> <pre>select_df = df[df['Column1'] &gt; 0][['Column1', 'Column2', 'Column3']]\n</pre> <p>or</p> <pre>select_df = df[['Column1', 'Column2', 'Column3']][df['Column1'] &gt; 0]\n</pre>"},{"location":"Pandas/Pandas.html#exercise-3","title":"Exercise 3\u00b6","text":"<p>Make a new dataframe with the year, month, day, number of cases and deaths, for countries in Europe.</p>"},{"location":"Pandas/Pandas.html#summary-functions","title":"Summary functions\u00b6","text":"<p>Pandas' Series and DataFrames are iterables, and can be given to any function that expects a list or Numpy Array, which allows them to be useful to many different libraries' functions.  For example, to compute basic statistics for a colum (<code>Series</code>):</p> <pre>df.describe() # describe numeric columns\ndf['Column1'].describe() # describe a particular column/series\ndf['Column1'].count()    # counts non-NA cells\ndf['Column1'].nunique()  # counts number of distinct elements in specified axis\ndf['Column1'].unique()   # returns array of unique values of Series, in order of appearance\ndf['Column1'].value_counts()  # returns list of unique values and how often they occur in the dataset\n\ndf['Column1'].max()\ndf['Column1'].mean()\ndf['Column1'].idxmax()\n</pre> <p>or for row:</p> <pre>df.loc['row_index_label'].sum() # count, std, mean, etc\n</pre> <p>or for all columns</p> <pre>df.mean() # default by column (= over all index)\n</pre> <p>or for all rows</p> <pre>df.mean(axis=1)\ndf.mean(axis='columns') # columns axis is axis 1\n</pre> <p>What the default axis for a method (or operation) will vary.</p> <p>Example documentation: <code>var</code></p>"},{"location":"Pandas/Pandas.html#exercise-4","title":"Exercise 4\u00b6","text":"<p>Which country has the maximum number of deaths reported on one day?</p> <p>Hint: check Pandas DataFrame API reference for more useful functions</p>"},{"location":"Pandas/Pandas.html#modifying-data","title":"Modifying Data\u00b6","text":"<p>Any transformation function can be performed on each element of a column   or on the entire DataFrame.</p> <p>You can assign a constant value:</p> <pre>df['Column20'] = 10\n</pre> <p>An iterable of values:</p> <pre>df['Column21'] = range(len(df), 0, -1)  # Replace the entire column with other values (length must match)\n</pre> <p>You can create a columns based on the transformation of another columns' numerical values:</p> <pre>df['Column22'] = df['Column1'] * 5\n</pre> <p>Or modify strings:</p> <pre>df['Column10'] = df['Column10'].str.upper()\n</pre> <p>Or even delete an entire column:</p> <pre>del df['B']\n</pre> <p>Column: a <code>pandas.Series</code> with the index of the rows</p>"},{"location":"Pandas/Pandas.html#exercise-5","title":"Exercise 5\u00b6","text":"<p>Which country has most daily deaths per 100.000?</p>"},{"location":"Pandas/Pandas.html#groupby-operations-and-sorting","title":"GroupBy Operations and Sorting\u00b6","text":"<p>In most of our tasks, getting single metrics from a dataset is not enough, and we often actually want to compare metrics between groups or conditions.</p> <p>The <code>groupby</code> method essentially splits the data into different groups depending on a variable of your choice, and allows you to apply summary functions on each group. For example, if you wanted to calculate the mean number of cases by month from a given our <code>DataFrame</code>:</p> <pre>df.groupby('month').cases.mean()\n</pre> <p>where \"month\" is a column name from the <code>DataFrame</code>.</p> <p>You can also group by multiple columns, by providing a list of column names:</p> <pre>df.groupby(['year', 'month']).cases.mean()\n</pre> <p>Aggregating by multiple columns will create an <code>MultiIndex</code> row-Index. You can access indices with more than one entry using tuples: <code>df.loc[(first_index, second_index)]</code></p> <p>The <code>groupby</code> method returns a GroupBy object, where the <code>.groups</code> attribute is a dictionary whose keys are the computed unique groups.</p> <p><code>GroupBy</code> objects are lazy, meaning they don't start calculating anything until they know the full pipeline.  This approach is called the \"Split-Apply-Combine\" workflow.  You can get more info on it in the UserGuide.</p>"},{"location":"Pandas/Pandas.html#exercise-6","title":"Exercise 6\u00b6","text":""},{"location":"Pandas/Pandas.html#multiple-statistics-per-group","title":"Multiple Statistics per Group\u00b6","text":"<p>Another piece of syntax we are going to look at, is the <code>aggregate</code> method for a <code>GroupBy</code> pandas objects, also available as <code>agg</code>.</p> <p>The aggregation functionality provided by this function allows multiple statistics to be calculated per group in one calculation.</p> <p>The instructions to the method <code>agg</code> are provided in the form of a dictionary, where the keys specify the columns upon which to apply the operation(s), and the value specify the function to run:</p> <pre>df.groupby(['year', 'month']).agg({'duration':'sum',\n                                   'network_type':'count',\n                                   'date':'first'})\n</pre> <p>Not a working example for our <code>DataFrame</code></p> <p>You can also apply multiple functions to one column in groups:</p> <pre>df.groupby(['year', 'month']).agg({'duration':[min, max, sum],\n                                   'network_type':'count',\n                                   'date':[min, 'first', 'nunique']})\n</pre> <p>Aggregating by multiple columns will create an <code>MultiIndex</code> row-Index. You can access indices with more than one entry using tuples: <code>df.loc[(first_index, second_index)]</code></p>"},{"location":"Pandas/Pandas.html#exercise-7","title":"Exercise 7\u00b6","text":"<p>Calculate how many were infected and how many died daily, on average, in each country in Europe?</p>"},{"location":"Pandas/Pandas.html#sorting","title":"Sorting\u00b6","text":"<p>Sort a dataset based on column values, with <code>sort_values()</code>:</p> <pre>df.sort_values(by='cases')\n</pre> <p>By default, values are sorted in ascending order (alhpabetically). To change to descending order, change the argument <code>ascending</code> to <code>False</code>:</p> <pre>df.sort_values(by='cases', ascending=False)\n</pre> <p>To sort the dataset based on index values, use the companion function <code>sort_index()</code>. This function has the same arguments and default order:</p> <pre>df.groupby(by='countriesAndTerritories').agg({'cases': 'sum', 'deaths': sum}).sort_index()\n</pre> <p>You can also sort by more than one column at a time:</p> <pre>df.sort_values(by=['countriesAndTerritories', 'cases'], ascending=False)\n</pre>"},{"location":"Pandas/Pandas.html#extra-handling-missing-values","title":"Extra: Handling Missing Values\u00b6","text":"<p>Missing values are often a concern in data science, for example in proteomics, and can be indicated with a <code>None</code> or <code>NaN</code> (np.nan in Numpy). Pandas DataFrames have several methods for detecting, removing and replacing these values:</p> method description <p><code>isna()</code> | Returns True for each NaN | <code>notna()</code> | Returns False for each NaN | <code>dropna()</code> | Returns just the rows without any NaNs |</p> <p>Detect missing values and retrieve rows where they are present in column \"Column1\":</p> <pre>missing_data_rows = df[df['Column1'].isna()]\n</pre>"},{"location":"Pandas/Pandas.html#imputation","title":"Imputation\u00b6","text":"<p>Imputation means replacing the missing values with real values.</p> method description <code>fillna()</code> Replaces the NaNs with values (provides lots of options) <code>ffill()</code> Replaces the Nans with the previous non-NaN value (equivalent to df.fillna(method='ffill') <code>bfill()</code> Replaces the Nans with the following non-NaN value (equivalent to df.fillna(method='bfill') <code>interpolate()</code> interpolates nans with previous and following values <p>Replace missing values with constant value across dataset:</p> <pre>df = df.fillna(0)\n</pre> <p>Replace missing values in a specific column:</p> <pre>df['Column1'] = df['Column1'].fillna(0)\n</pre> <p>Replace missing values with specific values per column, using a dictionary:</p> <pre>new_values = {'Column1': 0, 'Column2': 5, 'Column3': 'Unknown'}\ndf = df.fillna(values=new_values)\n</pre>"},{"location":"Pandas/Pandas.html#exercise-8","title":"Exercise 8\u00b6","text":"<p>Here we will use the titanic data which contains some missing values</p>"},{"location":"Pandas/Pandas.html#exercise-9","title":"Exercise 9\u00b6","text":"<p>Using the following DataFrame, solve the exercises below.</p> <p>recreate it in every exercise or copy it to avoid confusion:  <code>data_type_filled = data.copy()</code> Can you explain the problem?</p>"},{"location":"Pandas/Pandas.html#advanced-material","title":"Advanced material\u00b6","text":""},{"location":"Pandas/Pandas.html#wide-vs-long-formats","title":"Wide vs Long formats\u00b6","text":"<p>Two formats for Pandas DataFrames: wide and long.</p> <p>In the <code>wide</code> format, each feature (attribute) is a separate columns, while each row represents many features of the same individual entry. In the wide format, there are no repeated records, but there might be missing values. This format is preferable to perform statistics (e.g. mean).</p> <p>In the <code>long</code> format, each row only shows one feature for each individual entry, and there are multiple rows for each entry (one for each feature). We often use this format for graphic plotting.</p>  From https://www.statology.org/long-vs-wide-data/"},{"location":"Pandas/Pandas.html#lambda-and-mapping-functions","title":"Lambda and Mapping functions\u00b6","text":"<p>You can, of course, write your own functions in Python, but <code>lambda</code> functions are often a faster and easier way to write simple functions on the fly.</p> <p>To do so, you always start with the <code>lambda</code> keyword, followed by the names of the arguments, a colon and then the expression than specifies what we want the function to return. For example, if we want multiply two numbers:</p> <pre>max_value = lambda x, y: x * y\n\na = 55\nb = 34\nmax_value(a, b)\n</pre>"},{"location":"Pandas/Pandas.html#combining-dataframes","title":"Combining DataFrames\u00b6","text":"<p>When performing operations on a dataset, we might sometimes need to combine different DataFrames and/or other Series. Pandas has a few functions that allows to do that: <code>concat()</code>, <code>join()</code>, and <code>merge()</code>.</p> <p><code>concat()</code> is the simplest combining methods. It will smush together all the elements in a list, along a specified axis.</p> <pre>data1 = {'id': ['1', '2', '3', '4', '5'],\n         'Column1': ['A', 'C', 'E', 'G', 'I']}\ndf1 = pd.DataFrame(data1, columns = ['id', 'Column1'])\n\ndata2 = {'id': ['1', '2', '6', '7', '8'],\n         'Column1': ['K', 'M', 'O', 'Q', 'S'],\n         'Column2': ['L', 'N', 'P', 'R', 'T']}\ndf2 = pd.DataFrame(data2, columns = ['id', 'Column1', 'Column2'])\n\ncombined_df_rows = pd.concat([df1, df2], ignore_index=True)   # Concatenates along the row and adjusts row\n                                                              # labels automatically with \"ignore_index=True\"\n\ncombined_df_columns = pd.concat([df1, df2], axis=1)   # Concatenates along the columns\n</pre>"},{"location":"Pandas/Pandas.html#extra-exercises","title":"Extra exercises\u00b6","text":"<p>Might include usage of other packages, including numpy.</p>"},{"location":"Pandas/Pandas.html#simple-vectorized-operations","title":"Simple vectorized operations\u00b6","text":"<p>You want to plot the mathematical function</p> <p>$f(x) = log(-1.3x^2 + 1.4^x + 7x + 50)$</p> <p>For the numbers in $[0, 20]$. To do this, you need to create a vector <code>xs</code> with lots of numbers between 0 and 20, and a vector <code>ys</code> with $f$ evaluated at every element of <code>xs</code>. A vector is a <code>1d-ndarray</code>.</p> <p>To get a hang of vectorized operations, solve the problem without using any loops:</p>"},{"location":"Pandas/Pandas.html#create-a-pandasseries-xs-with-1000-evenly-spaced-points-between-0-and-20","title":"Create a <code>pandas.Series</code> <code>xs</code> with 1000 evenly spaced points between 0 and 20\u00b6","text":""},{"location":"Pandas/Pandas.html#create-a-python-function-f-as-seen-above","title":"Create a Python function $f$ as seen above\u00b6","text":""},{"location":"Pandas/Pandas.html#evaluate-ys-fx-ie-f-of-every-element-of-xs","title":"Evaluate <code>ys</code> = $f(x)$, i.e. $f$ of every element of <code>xs</code>.\u00b6","text":""},{"location":"Pandas/Pandas.html#what-is-the-mean-and-standard-deviation-of-ys","title":"What is the mean and standard deviation of <code>ys</code>?\u00b6","text":""},{"location":"Pandas/Pandas.html#how-many-elements-of-ys-are-below-0-between-1-and-2-both-exclusive","title":"How many elements of. <code>ys</code> are below 0? Between 1 and 2, both exclusive?\u00b6","text":"<p>Hint: You can use a comparison operator to get an array of dtype <code>bool</code>. To get the number of elements that are <code>True</code>, you can exploit the fact that <code>True</code> behaves similar to the number 1, and <code>False</code> similar to the number 0.</p>"},{"location":"Pandas/Pandas.html#what-is-the-minimum-and-maximum-value-of-ys","title":"What is the minimum and maximum value of <code>ys</code>?\u00b6","text":""},{"location":"Pandas/Pandas.html#create-a-series-non_negatives-which-contain-all-the-values-of-ys-that-are-nonnegative","title":"Create a series <code>non_negatives</code>, which contain all the values of <code>ys</code> that are nonnegative\u00b6","text":""},{"location":"Pandas/Pandas.html#extra-use-matplotlib-to-plot-xs-vs-ys-directly-from-your-series-object","title":"Extra: Use <code>matplotlib</code> to plot <code>xs</code> vs <code>ys</code> directly from your <code>Series</code> object\u00b6","text":""},{"location":"Pandas/Pandas.html#species-depth-matrix","title":"Species depth matrix\u00b6","text":"<p>Load in the data <code>depths.csv</code>. As you can see in drive preview, there are 11 columns, with columns 2-11 representing a sample from a human git microbiome. Each row represents a genome of a micro-organism, a so-called \"operational taxonomic unit at 97% sequence identity\" (OTU_97). The first row gives the name of the genome. The values in the matrix represents the relative abundance (or depth) of that micro-organism in that sample, i.e. how much of the micro-organism there is.</p>"},{"location":"Pandas/Pandas.html#load-in-the-matrix-in-a-pandasdataframe","title":"Load in the matrix in a <code>pandas.DataFrame</code>\u00b6","text":""},{"location":"Pandas/Pandas.html#how-many-otus-are-there-show-how-you-figured-it-out","title":"How many OTUs are there? Show how you figured it out.\u00b6","text":""},{"location":"Pandas/Pandas.html#find-the-otu-otu_97411890-what-is-the-mean-and-standard-deviations-of-the-depths-across-the-10-samples-of-this-otu","title":"Find the OTU \"OTU_97.41189.0\". What is the mean and standard deviations of the depths across the 10 samples of this OTU?\u00b6","text":""},{"location":"Pandas/Pandas.html#how-many-samples-have-0-depth-of-that-otu-or-rather-below-detection-limit","title":"How many samples have 0 depth of that OTU? (or rather, below detection limit?)\u00b6","text":""},{"location":"Pandas/Pandas.html#what-is-the-mean-and-standard-deviation-if-you-exclude-those-samples","title":"What is the mean and standard deviation if you exclude those samples?\u00b6","text":""},{"location":"Pandas/Pandas.html#extra-how-would-you-get-all-the-means-and-std-deviations-in-one-go","title":"Extra: How would you get all the means and std. deviations in one go?\u00b6","text":""},{"location":"Pandas/Pandas.html#we-are-not-interested-in-otus-present-in-fewer-than-4-samples-remove-all-those-otus","title":"We are not interested in OTUs present in fewer than 4 samples. Remove all those OTUs.\u00b6","text":""},{"location":"Pandas/Pandas.html#how-many-otus-did-you-remove","title":"How many OTUs did you remove?\u00b6","text":""},{"location":"Pandas/Pandas.html#how-many-otus-have-a-depth-of-5-in-all-10-samples-hint-npall","title":"How many OTUs have a depth of &gt; 5 in all 10 samples? (hint: <code>np.all</code>)\u00b6","text":""},{"location":"Pandas/Pandas.html#filtering-and-normalization","title":"Filtering and Normalization\u00b6","text":"<p>After discarding all OTUs present in fewer than 4 samples, sort the OTUs, do the following:</p> <ul> <li><p>Calculate the mean depth across samples for each remaining OTU.</p> </li> <li><p>Normalize the remaining OTUs such that each row sum to 0 and have a standard deviation of 1 (so-called z-score normalization)</p> </li> <li><p>Print the remaining OTUs to a new file in descending order by their mean depth, with a 12th column giving the mean depth, and columns 1-11 being the normalized depth. Make sure that your file looks like the input file (except with the 12th column)</p> </li> </ul>"},{"location":"Recap/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [recap.ipynb](recap.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Recap/recap.ipynb)| Recap</p>"},{"location":"Variables_data_types/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [variables.ipynb](variables.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Variables_data_types/variables.ipynb) | Variables and data types</p>"},{"location":"Variables_data_types/variables.html","title":"1. Variables","text":"<p>A variable is a named symbol that holds a value.</p> <p>Variable containers --&gt; name and value</p> <ul> <li><p>Create variables by assigning a value to a name (just like using variables in math).</p> </li> <li><p>Variable names should be meaningful, i.e. not just <code>a</code>, <code>b</code>, <code>c</code></p> </li> <li><p>Variables are always assigned with the variable name on the left and the value on the right of the *equals* sign. For instance:</p> <ul> <li><code>a_variable = 100</code></li> <li>assigned to other variables: <code>another_variable = a_variable</code></li> <li>reassigned at any time: <code>a_variable = 435</code></li> <li>assigning several variables at the same time: <code>all, at, once = 1, 130, 43</code></li> </ul> </li> <li><p>Variables must be assigned before they can be used.</p> </li> </ul> In\u00a0[\u00a0]: Copied! <pre># Create a variable x by assigning a value to x\nx = 100\nprint(x)\n\n# What is the container and what are the data here?\n</pre> # Create a variable x by assigning a value to x x = 100 print(x)  # What is the container and what are the data here? <pre>100\n</pre> <p>In Python, you can name your variables whatever you want, with some restrictions:</p> <ol> <li><p>Variables must start with a letter or underscore:</p> <ul> <li><code>_yes</code>: Valid name.</li> <li><code>2no</code>: Not valid!</li> </ul> </li> <li><p>The rest of the name must consist of letters and numbers (i.e. alpanumeric). If you need to use a multi_word variable name, underscores can be used:</p> <ul> <li><code>yes2</code>: Valid name.</li> <li><code>hey@no</code>: Not valid!</li> <li><code>hey_no</code>: Valid name.</li> </ul> </li> <li><p>Names are case-sensitive</p> <ul> <li><code>Yes</code> and <code>yes</code> are two different variables.</li> </ul> </li> <li><p>Each variable's name must be unique. No other variable can have its name.</p> </li> </ol> In\u00a0[\u00a0]: Copied! <pre># Try it out\n_2x = 100\nprint(_2x)\n\n# What can be the alternatives to make this variable naming work?\n</pre> # Try it out _2x = 100 print(_2x)  # What can be the alternatives to make this variable naming work? <pre>100\n</pre> <p>In any assignment, the assigned value must always be a valid data type.</p> <p>Python data types include (among others):</p> <ul> <li>numbers:<ul> <li><code>int</code>: an integer, e.g. <code>1</code>, <code>2</code>, <code>3</code></li> <li><code>float</code>: a floating point number with a decimal point, e.g. <code>1.2</code>, <code>2999.197</code>, <code>-160.8</code></li> </ul> </li> <li><code>str</code>: (string) a sequence of Unicode characters, e.g. \"Kate\" or \"\u7a0b\u5e8f\u8bbe\u8ba1\"</li> <li><code>bool</code>: True or False</li> </ul> <p>You can check a variable's type with the <code>type()</code> function.</p> In\u00a0[\u00a0]: Copied! <pre># Try it out\nvar = -1\nprint(var)\nprint(type(var))\n</pre> # Try it out var = -1 print(var) print(type(var)) <pre>-1\n&lt;class 'int'&gt;\n</pre> In\u00a0[\u00a0]: Copied! <pre>var2 = -2.099874565\nprint(var2)\nprint(type(var2))\n</pre> var2 = -2.099874565 print(var2) print(type(var2)) <pre>-2.099874565\n&lt;class 'float'&gt;\n</pre> In\u00a0[\u00a0]: Copied! <pre>my_string = \"Hello world!\"\nprint(my_string)\nprint(type(my_string))\n</pre> my_string = \"Hello world!\" print(my_string) print(type(my_string)) <pre>Hello world!\n&lt;class 'str'&gt;\n</pre> In\u00a0[\u00a0]: Copied! <pre>bool_var = True\nprint(bool_var)\nprint(type(bool_var))\n</pre> bool_var = True print(bool_var) print(type(bool_var)) <pre>True\n&lt;class 'bool'&gt;\n</pre> <p>String literals in Python can be declared with either single or double quotes.</p> <pre><code>my_other_str = 'a hat'\nmy_str = \"a cat\"\n\n\n</code></pre> <p>Either one is perfectly fine; but make sure you stick to the same convention throughout the same file.</p> In\u00a0[\u00a0]: Copied! <pre># let's see what types of error messages there are\n</pre> # let's see what types of error messages there are In\u00a0[\u00a0]: Copied! <pre>i\n</pre> i <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n&lt;ipython-input-9-397d543883c5&gt; in &lt;module&gt;()\n----&gt; 1 i\n\nNameError: name 'i' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>1 / 0\n</pre> 1 / 0 <pre>\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\n&lt;ipython-input-10-bc757c3fda29&gt; in &lt;module&gt;()\n----&gt; 1 1 / 0\n\nZeroDivisionError: division by zero</pre> In\u00a0[\u00a0]: Copied! <pre>1 %% 2\n</pre> 1 %% 2 <pre>\n  File \"&lt;ipython-input-11-0165dc641888&gt;\", line 1\n    1 %% 2\n       ^\nSyntaxError: invalid syntax\n</pre> In\u00a0[\u00a0]: Copied! <pre>my_string = \"Hello world!\"\nmy_string + 1\n</pre> my_string = \"Hello world!\" my_string + 1 <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-12-9aa644ec6cb4&gt; in &lt;module&gt;()\n      1 my_string = \"Hello world!\"\n----&gt; 2 my_string + 1\n\nTypeError: can only concatenate str (not \"int\") to str</pre> <p>b. Is <code>24hrs</code>  a valid variable name?</p> In\u00a0[\u00a0]: Copied! <pre># Your code goes here\n</pre> # Your code goes here <p>c. Is <code>my_1st_variable</code>  a valid variable name?</p> In\u00a0[\u00a0]: Copied! <pre># Your code goes here\n</pre> # Your code goes here <p>d. Please complete the four steps below.</p> <ol> <li>Use a number of your choice and store it in a variable. Multiply that variable by <code>2</code> and print this new variable.</li> <li>Use a second number of your choice and multiply it with the initial variable used in (1).</li> <li>Find out if the result is even (divisible by 2) or odd. Hint: Use the modulo operator.</li> <li>What is the type of the final variable?</li> </ol> In\u00a0[\u00a0]: Copied! <pre># Your code goes here\n</pre> # Your code goes here"},{"location":"Variables_data_types/variables.html#variables-and-data-types","title":"Variables and Data Types\u00b6","text":""},{"location":"Variables_data_types/variables.html#variable-assignment-and-naming-restrictions","title":"Variable Assignment and naming restrictions\u00b6","text":""},{"location":"Variables_data_types/variables.html#data-types","title":"Data Types\u00b6","text":""},{"location":"Variables_data_types/variables.html#numbers-and-operators","title":"Numbers and Operators\u00b6","text":""},{"location":"Variables_data_types/variables.html#numbers","title":"Numbers\u00b6","text":"<p>Two main types of numbers:</p> <ul> <li>Integers: <code>56, 3, -90</code></li> <li>Floating Points: <code>5.666, 0.0, -8.9</code></li> </ul>"},{"location":"Variables_data_types/variables.html#math-operators","title":"Math Operators\u00b6","text":"<ul> <li>addition: <code>+</code></li> <li>subtraction: <code>-</code></li> <li>multiplication: <code>*</code></li> <li>division: <code>/</code></li> <li>integer division: <code>//</code></li> <li>exponentiation, power: <code>**</code></li> <li>modulo: <code>%</code></li> </ul> <p>The usual rules of algebra apply.</p>"},{"location":"Variables_data_types/variables.html#strings","title":"Strings\u00b6","text":"<p>Strings are containers of characters.</p> <p>There are different encodings for characters. The default in Python 3 is the Unicode encoding which includes characters from European and Asian languages.</p>"},{"location":"Variables_data_types/variables.html#declaring-strings","title":"Declaring strings\u00b6","text":""},{"location":"Variables_data_types/variables.html#reading-error-messages","title":"Reading error messages\u00b6","text":"<p>Let's talk about error messages! They look red and scary, but they're actually just here to help you. Error messages tell you that you are trying to do something that is either not allowed, not possible, ambiguous, not meaningful or written using the wrong syntax.</p> <p>You will encounter error messages ALL THE TIME; especially when learning to program, but also as an advanced programmer. That's why it's worth knowing how the read them.</p> <p>Look at the error message below. You can find the most important piece of information on the last line: this is the actual error and this is where you should always look first. In the part above the last line, you can see in which line of your program the error occurs in.</p> <pre>---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\n&lt;ipython-input-10-bc757c3fda29&gt; in &lt;module&gt;\n----&gt; 1 1 / 0                                     # the arrow points towards the line where the error occurs\n\nZeroDivisionError: division by zero               # this is the actual type of error\n</pre>"},{"location":"Variables_data_types/variables.html#exercise","title":"Exercise\u00b6","text":"<p>~ 15 minutes</p> <p>a. Is the following statement correct? Variables must be assigned before they can be used.</p>"},{"location":"Visualizations/index.html","title":"Index","text":"<p>   notebook             | content ----                 | ------ [plotly.ipynb](plotly.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/march_2023/Visualizations/plotly.ipynb)| Plotly Express library [Be aware: [Plots stays interactive in nbviewer](https://nbviewer.org/github/Center-for-Health-Data-Science/PythonTsunami/blob/march_2023/Visualizations/plotly.ipynb#Bar-Charts)] [PlotlyExpress_ComprehensiveGuide.ipynb](PlotlyExpress_ComprehensiveGuide.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/Center-for-Health-Data-Science/PythonTsunami/blob/oct_2022_3days/Visualizations/PlotlyExpress_ComprehensiveGuide.ipynb)| PlotlyExpress library guide (extensive external resource)  ## Installing Plotly  In order to [run plotly in jupyter lab](https://plotly.com/python/getting-started/#jupyterlab-support) you will need to add an labextension:  </p><pre><code># JupyterLab renderer support\njupyter labextension install jupyterlab-plotly@4.14.3\n# OPTIONAL: Jupyter widgets extension\njupyter labextension install @jupyter-widgets/jupyterlab-manager plotlywidget@4.14.3\n</code></pre>  ## Articles  - python [plotting libraries](https://pbpython.com/python-vis-flowchart.html)"},{"location":"Visualizations/plotly.html","title":"6. Visualizations","text":"In\u00a0[2]: Copied! <pre>import pandas as pd\nimport plotly.express as px\n</pre> import pandas as pd import plotly.express as px <p>1. Using lists of values.</p> <p>We can create two lists of values for the <code>x</code> and <code>y</code> axis and use them as parameters for the line chart plot</p> In\u00a0[1]: Copied! <pre>year = list(range(1996,2020,4))\nmedals = [1,4,5,9,1,2]\n\nprint(year)\nprint(medals)\n</pre> year = list(range(1996,2020,4)) medals = [1,4,5,9,1,2]  print(year) print(medals) <pre>[1996, 2000, 2004, 2008, 2012, 2016]\n[1, 4, 5, 9, 1, 2]\n</pre> In\u00a0[3]: Copied! <pre>px.line(x = year, y = medals)\n</pre> px.line(x = year, y = medals) <p>2. Using <code>pandas.Series</code></p> <p>This is very much like using lists</p> In\u00a0[4]: Copied! <pre>year_series = pd.Series(year)\nmedals_series = pd.Series(medals)\n\nprint(year_series) \nprint(medals_series)\n</pre> year_series = pd.Series(year) medals_series = pd.Series(medals)  print(year_series)  print(medals_series) <pre>0    1996\n1    2000\n2    2004\n3    2008\n4    2012\n5    2016\ndtype: int64\n0    1\n1    4\n2    5\n3    9\n4    1\n5    2\ndtype: int64\n</pre> In\u00a0[5]: Copied! <pre>px.line(x = year_series, y = medals_series)\n</pre> px.line(x = year_series, y = medals_series) <p>3. Using <code>pandas.DataFrame</code></p> <p>This is most of the time the best option. We can plot things directly from our DataFrame of interest. We need to give the <code>px.chart_type()</code> function our dataframe using the argument <code>data_frame</code>. Then we only need to specify as <code>x</code> and <code>y</code> axis the name of the columns we want to use!</p> In\u00a0[6]: Copied! <pre># We create our dataframe \ndf = pd.DataFrame({\"Year\" : year, \"Medals\" : medals})\ndf.head()\n</pre> # We create our dataframe  df = pd.DataFrame({\"Year\" : year, \"Medals\" : medals}) df.head() Out[6]: Year Medals 0 1996 1 1 2000 4 2 2004 5 3 2008 9 4 2012 1 In\u00a0[7]: Copied! <pre>px.line(data_frame = df, x = \"Year\" , y = \"Medals\")\n</pre> px.line(data_frame = df, x = \"Year\" , y = \"Medals\") <p><code>Note</code>: If our dataframe is in wide format, we may need to change the shape to long format. This means that we always need to have our variables of interest as columns! Have a look at the melt method in Pandas. For example, lets make a wide dataframe:</p> In\u00a0[19]: Copied! <pre>df = pd.DataFrame({'Year': {0: '2004', 1: '2008', 2: '2012', 3: '2016'},\n                   'Canada': {0: 4, 1: 3, 2: 5, 3: 3},\n                   'USA': {0: 5, 1: 9, 2: 1, 3: 2}})\n\ndf\n</pre> df = pd.DataFrame({'Year': {0: '2004', 1: '2008', 2: '2012', 3: '2016'},                    'Canada': {0: 4, 1: 3, 2: 5, 3: 3},                    'USA': {0: 5, 1: 9, 2: 1, 3: 2}})  df Out[19]: Year Canada USA 0 2004 4 5 1 2008 3 9 2 2012 5 1 3 2016 3 2 <p>In this case, we would like to have a column named \"Countries\" that will encompass Canada and USA. We use the <code>.melt()</code> method to do this.</p> In\u00a0[32]: Copied! <pre>long_df = pd.melt(df, id_vars=['Year'], value_vars=['Canada', 'USA'])\nlong_df\n</pre> long_df = pd.melt(df, id_vars=['Year'], value_vars=['Canada', 'USA']) long_df Out[32]: Year variable value 0 2004 Canada 4 1 2008 Canada 3 2 2012 Canada 5 3 2016 Canada 3 4 2004 USA 5 5 2008 USA 9 6 2012 USA 1 7 2016 USA 2 <p>We also may want update the column names of our long_df to something more meaningful. Do you remember how to do that from yesterday?</p> In\u00a0[33]: Copied! <pre>#update column names to 'country' and 'medals'\nlong_df.rename(columns={'variable': 'country', 'value': 'medals'}, inplace=True)\n</pre> #update column names to 'country' and 'medals' long_df.rename(columns={'variable': 'country', 'value': 'medals'}, inplace=True) <p>Now we can use the long format dataframe to plot</p> In\u00a0[34]: Copied! <pre>px.line(data_frame = long_df, x = \"Year\" , y = \"medals\", color = \"country\")\n</pre> px.line(data_frame = long_df, x = \"Year\" , y = \"medals\", color = \"country\") In\u00a0[36]: Copied! <pre>fig = px.line(data_frame = long_df, x = \"Year\" , y = \"medals\", color = \"country\")\n</pre> fig = px.line(data_frame = long_df, x = \"Year\" , y = \"medals\", color = \"country\") In\u00a0[37]: Copied! <pre>fig.show()\n</pre> fig.show() <p>We can use <code>.to_dict().keys()</code> to see all keys inside the fig object:</p> In\u00a0[40]: Copied! <pre>fig.to_dict().keys()\n</pre> fig.to_dict().keys() Out[40]: <pre>dict_keys(['data', 'layout'])</pre> <p>There are two items inside <code>fig.data</code> because we have two lines, one for Canada and one for USA.</p> In\u00a0[38]: Copied! <pre>fig.data\n</pre> fig.data Out[38]: <pre>(Scatter({\n     'hovertemplate': 'country=Canada&lt;br&gt;Year=%{x}&lt;br&gt;medals=%{y}&lt;extra&gt;&lt;/extra&gt;',\n     'legendgroup': 'Canada',\n     'line': {'color': '#636efa', 'dash': 'solid'},\n     'marker': {'symbol': 'circle'},\n     'mode': 'lines',\n     'name': 'Canada',\n     'orientation': 'v',\n     'showlegend': True,\n     'x': array(['2004', '2008', '2012', '2016'], dtype=object),\n     'xaxis': 'x',\n     'y': array([4, 3, 5, 3]),\n     'yaxis': 'y'\n }), Scatter({\n     'hovertemplate': 'country=USA&lt;br&gt;Year=%{x}&lt;br&gt;medals=%{y}&lt;extra&gt;&lt;/extra&gt;',\n     'legendgroup': 'USA',\n     'line': {'color': '#EF553B', 'dash': 'solid'},\n     'marker': {'symbol': 'circle'},\n     'mode': 'lines',\n     'name': 'USA',\n     'orientation': 'v',\n     'showlegend': True,\n     'x': array(['2004', '2008', '2012', '2016'], dtype=object),\n     'xaxis': 'x',\n     'y': array([5, 9, 1, 2]),\n     'yaxis': 'y'\n }))</pre> In\u00a0[39]: Copied! <pre>fig.layout\n</pre> fig.layout Out[39]: <pre>Layout({\n    'legend': {'title': {'text': 'country'}, 'tracegroupgap': 0},\n    'margin': {'t': 60},\n    'template': '...',\n    'xaxis': {'anchor': 'y', 'domain': [0.0, 1.0], 'title': {'text': 'Year'}},\n    'yaxis': {'anchor': 'x', 'domain': [0.0, 1.0], 'title': {'text': 'medals'}}\n})</pre> <p>As you can see, there are many attributes inside this dictionary. This means that a plot can be modified even after it is created. For example, we can use a layout template to modify the design of a plot or change the plot and axis titles</p> In\u00a0[42]: Copied! <pre>fig.update_layout(template=\"plotly_dark\", title = \"Example\", yaxis_title='Medals Earned')\n</pre> fig.update_layout(template=\"plotly_dark\", title = \"Example\", yaxis_title='Medals Earned') <p>This update is not only displayed, it has also changed the plot object. See how the <code>layout</code> part is different now:</p> In\u00a0[43]: Copied! <pre>fig.layout\n</pre> fig.layout Out[43]: <pre>Layout({\n    'legend': {'title': {'text': 'country'}, 'tracegroupgap': 0},\n    'margin': {'t': 60},\n    'template': '...',\n    'title': {'text': 'Example'},\n    'xaxis': {'anchor': 'y', 'domain': [0.0, 1.0], 'title': {'text': 'Year'}},\n    'yaxis': {'anchor': 'x', 'domain': [0.0, 1.0], 'title': {'text': 'Medals Earned'}}\n})</pre> <p>We can also modify the attributes of the data using the <code>update_traces</code> method. For example, we change all lines to be dashed:</p> In\u00a0[44]: Copied! <pre>fig.update_traces(line={\"dash\":\"dash\"})\n</pre> fig.update_traces(line={\"dash\":\"dash\"}) <p>We will see more ways of modifying the plots as we go through the different types of plots we can make!</p> In\u00a0[49]: Copied! <pre>gapminder_data = px.data.gapminder()\ngapminder_data\n</pre> gapminder_data = px.data.gapminder() gapminder_data Out[49]: country continent year lifeExp pop gdpPercap iso_alpha iso_num 0 Afghanistan Asia 1952 28.801 8425333 779.445314 AFG 4 1 Afghanistan Asia 1957 30.332 9240934 820.853030 AFG 4 2 Afghanistan Asia 1962 31.997 10267083 853.100710 AFG 4 3 Afghanistan Asia 1967 34.020 11537966 836.197138 AFG 4 4 Afghanistan Asia 1972 36.088 13079460 739.981106 AFG 4 ... ... ... ... ... ... ... ... ... 1699 Zimbabwe Africa 1987 62.351 9216418 706.157306 ZWE 716 1700 Zimbabwe Africa 1992 60.377 10704340 693.420786 ZWE 716 1701 Zimbabwe Africa 1997 46.809 11404948 792.449960 ZWE 716 1702 Zimbabwe Africa 2002 39.989 11926563 672.038623 ZWE 716 1703 Zimbabwe Africa 2007 43.487 12311143 469.709298 ZWE 716 <p>1704 rows \u00d7 8 columns</p> <p>For now we would like to only use countries from Oceania. Can you help me to subset the dataframe?</p> In\u00a0[\u00a0]: Copied! <pre>#Let's subset the data\n</pre> #Let's subset the data In\u00a0[\u00a0]: Copied! <pre>#@title Solution\ndf = gapminder_data.loc[gapminder_data['continent'] == 'Oceania']\ndf.sample(5)\n</pre> #@title Solution df = gapminder_data.loc[gapminder_data['continent'] == 'Oceania'] df.sample(5) In\u00a0[74]: Copied! <pre># We can separate the data from the different countries by color using the argument `color`\n# Separating the px.line call into several lines like this is purely aesthetic. It does not influence the flow of the execution. \nfig = px.line(df, \n              x=\"year\", \n              y=\"lifeExp\", \n              color='country')\nfig.show()\n</pre> # We can separate the data from the different countries by color using the argument `color` # Separating the px.line call into several lines like this is purely aesthetic. It does not influence the flow of the execution.  fig = px.line(df,                x=\"year\",                y=\"lifeExp\",                color='country') fig.show() <p>You want, instead, to change the color of all the lines, we need to use the method <code>update_traces()</code></p> In\u00a0[69]: Copied! <pre>fig.update_traces(line={\"color\":\"red\"})\nfig.show()\n</pre> fig.update_traces(line={\"color\":\"red\"}) fig.show() In\u00a0[75]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"})\n\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"})  fig.show() In\u00a0[76]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"}, \n              title=\"Life expectancy in Oceania\")\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},                title=\"Life expectancy in Oceania\") fig.show() In\u00a0[77]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              title=\"Life expectancy per year\",\n              text=\"lifeExp\") #The text argument allows us to plot the actual number on the datapoint\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               color_discrete_map = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               title=\"Life expectancy per year\",               text=\"lifeExp\") #The text argument allows us to plot the actual number on the datapoint fig.show() <p>Notice how the text argument positioned the text right on top of the data points? We can modify this behaviour by updating our figures using the <code>update_traces()</code> method, which will modify all data points inside <code>fig.data</code>.</p> In\u00a0[78]: Copied! <pre>fig.update_traces(textposition=\"top center\")\nfig.show()\n</pre> fig.update_traces(textposition=\"top center\") fig.show() In\u00a0[79]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              text=\"lifeExp\",\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              line_dash = \"country\",\n              title=\"Life expectancy per year\")\n\nfig.update_traces(textposition=\"top center\")\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               text=\"lifeExp\",               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               line_dash = \"country\",               title=\"Life expectancy per year\")  fig.update_traces(textposition=\"top center\") fig.show() <p>If you want, instead to change all lines to be dashed, you need to use the <code>update_traces()</code> method as shown above. You can choose one of <code>dash</code>, <code>dot</code> or the default <code>solid</code>.</p> In\u00a0[\u00a0]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              text=\"lifeExp\",\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              title=\"Life expectancy per year\")\n\nfig.update_traces(textposition=\"top center\", line = {\"dash\" : \"dot\"}) #now all lines are dotted, it does not depend on the country column anymore.\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               text=\"lifeExp\",               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               title=\"Life expectancy per year\")  fig.update_traces(textposition=\"top center\", line = {\"dash\" : \"dot\"}) #now all lines are dotted, it does not depend on the country column anymore. fig.show() In\u00a0[80]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color=\"country\",\n              text=\"lifeExp\",\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              line_dash = \"country\",\n              line_dash_map = {\"Australia\":\"solid\", \"New Zealand\": \"dot\"},\n              title=\"Life expectancy per year\")\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color=\"country\",               text=\"lifeExp\",               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               line_dash = \"country\",               line_dash_map = {\"Australia\":\"solid\", \"New Zealand\": \"dot\"},               title=\"Life expectancy per year\") fig.show() In\u00a0[\u00a0]: Copied! <pre>#create the dataframe and verify that it has the data you want\n</pre> #create the dataframe and verify that it has the data you want In\u00a0[\u00a0]: Copied! <pre>#now make the plot\n</pre> #now make the plot <ol> <li>Color by the country and change the line type by the continent</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Change the template of the plot. Check out templates here</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[107]: Copied! <pre>df = gapminder_data.loc[gapminder_data[\"continent\"] == 'Europe']\n\nfig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 color=\"country\")\nfig.show()\n</pre> df = gapminder_data.loc[gapminder_data[\"continent\"] == 'Europe']  fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  color=\"country\") fig.show() In\u00a0[100]: Copied! <pre>fig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 color=\"country\",\n                 symbol='country')\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  color=\"country\",                  symbol='country') fig.show() In\u00a0[101]: Copied! <pre>fig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 color=\"country\",\n                 size='pop') # Using population as the size for the plot\n\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  color=\"country\",                  size='pop') # Using population as the size for the plot  fig.show() In\u00a0[102]: Copied! <pre>fig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 trendline = \"ols\") # fitting a trendline with ordinary least squares\n\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  trendline = \"ols\") # fitting a trendline with ordinary least squares  fig.show() <p>If you have separated the countries using the <code>color</code> argument, you will get a trendline per country.</p> <p>This will look quite ugly since there are many countries. Some of them actually look like the relationship could be linear.</p> In\u00a0[103]: Copied! <pre>fig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 color=\"country\",\n                 trendline = \"ols\")\n\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  color=\"country\",                  trendline = \"ols\")  fig.show() <p>If you want to color by a variable but still have a global trend, use the argument <code>trendline_scope=\"overall\"</code>. We will also change to a none-linear fitting called LOWESS (Locally Weighted Scatterplot Smoothing). This type of fit is also sometimes called LOESS if you are familiar with that term.</p> In\u00a0[108]: Copied! <pre>fig = px.scatter(df,\n                 x=\"lifeExp\",\n                 y=\"gdpPercap\",\n                 color=\"country\",\n                 trendline = \"lowess\",\n                 trendline_scope=\"overall\")\n\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"lifeExp\",                  y=\"gdpPercap\",                  color=\"country\",                  trendline = \"lowess\",                  trendline_scope=\"overall\")  fig.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Make two separate plots that model the correlation between GDP and population for each country, once using an OLS fit and once a LOWESS fit. Which fit do you think looks more convincing?</li> </ol> In\u00a0[\u00a0]: Copied! <pre>#ols\n</pre> #ols In\u00a0[\u00a0]: Copied! <pre>#lowess\n</pre> #lowess In\u00a0[114]: Copied! <pre>df = gapminder_data.loc[gapminder_data[\"continent\"] == 'Oceania']\nfig = px.bar(df, x='year', y='pop', color='country')\nfig.show()\n</pre> df = gapminder_data.loc[gapminder_data[\"continent\"] == 'Oceania'] fig = px.bar(df, x='year', y='pop', color='country') fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.bar(df, x='pop', y='year', color='country', orientation=\"h\")\nfig.show()\n</pre> fig = px.bar(df, x='pop', y='year', color='country', orientation=\"h\") fig.show() In\u00a0[117]: Copied! <pre>df = px.data.medals_long()\ndf\n</pre> df = px.data.medals_long() df Out[117]: nation medal count 0 South Korea gold 24 1 China gold 10 2 Canada gold 9 3 South Korea silver 13 4 China silver 15 5 Canada silver 12 6 South Korea bronze 11 7 China bronze 8 8 Canada bronze 12 <p>We would like to see the different types of medals (gold, silver, bronze) per country.</p> <p>Luckily for us the data is already aggregated so we can directly use the <code>count</code> column for the height of the bar (the y-axis).</p> In\u00a0[118]: Copied! <pre>fig = px.bar(df, x=\"medal\", y=\"count\", color=\"nation\", text=\"nation\")\nfig.show()\n</pre> fig = px.bar(df, x=\"medal\", y=\"count\", color=\"nation\", text=\"nation\") fig.show() <p>By default, Plotly will scale and rotate text labels to maximize the number of visible labels, which can result in a variety of text angles and sizes and positions in the same figure. The <code>textfont</code>, <code>textposition</code> and <code>textangle</code> trace attributes can be used to control these.</p> <p>In addition, you can use the <code>text_auto</code> argument to format the text shown in the plot`</p> <p>This is the default behaviour</p> <p>We will plot populations of European countries and label the bars with auto text.</p> <p>Let's use everything we have learned yesterday and make the mother of all selections: Rows for Europe, for the year 2007 and only for countries with a population of greater than 2 mio (nobody cares about Liechtenstein!).</p> In\u00a0[134]: Copied! <pre>df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'] == 2007) &amp; (gapminder_data['pop']&gt;2.e6)]\ndf.head()\n</pre> df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'] == 2007) &amp; (gapminder_data['pop']&gt;2.e6)] df.head() Out[134]: country continent year lifeExp pop gdpPercap iso_alpha iso_num 23 Albania Europe 2007 76.423 3600523 5937.029526 ALB 8 83 Austria Europe 2007 79.829 8199783 36126.492700 AUT 40 119 Belgium Europe 2007 79.441 10392226 33692.605080 BEL 56 155 Bosnia and Herzegovina Europe 2007 74.852 4552198 7446.298803 BIH 70 191 Bulgaria Europe 2007 73.005 7322858 10680.792820 BGR 100 In\u00a0[122]: Copied! <pre>fig = px.bar(df, y='pop', x='country', text_auto='.2s', #text_auto will show only two numbers\n            title=\"Default: various text sizes, positions and angles\")\nfig.show()\n</pre> fig = px.bar(df, y='pop', x='country', text_auto='.2s', #text_auto will show only two numbers             title=\"Default: various text sizes, positions and angles\") fig.show() <p>Again we can use <code>update_traces()</code> to control the angle of the text (set to 0) and the position (outside the bar) and the font size.</p> In\u00a0[125]: Copied! <pre>fig = px.bar(df, y='pop', x='country', text_auto='.2s',\n            title=\"Controlled text sizes, positions and angles\")\n\nfig.update_traces(textfont_size=12, textangle=0, textposition=\"outside\")\nfig.update_layout(yaxis_range=[0,10**8]) # We increase the range of the plot so the text fits\nfig.show()\n</pre> fig = px.bar(df, y='pop', x='country', text_auto='.2s',             title=\"Controlled text sizes, positions and angles\")  fig.update_traces(textfont_size=12, textangle=0, textposition=\"outside\") fig.update_layout(yaxis_range=[0,10**8]) # We increase the range of the plot so the text fits fig.show() In\u00a0[127]: Copied! <pre>fig.update_xaxes(categoryorder='total ascending')\nfig.show()\n</pre> fig.update_xaxes(categoryorder='total ascending') fig.show() <p>We could also impose alphabetic sort (this is actually the default!)</p> In\u00a0[130]: Copied! <pre>fig.update_xaxes(categoryorder='category ascending')\nfig.show()\n</pre> fig.update_xaxes(categoryorder='category ascending') fig.show() <p>Lastly, you could impose you own custom order by using a category array:</p> <p>Can someone see what this is sorted by (roughly)?</p> In\u00a0[132]: Copied! <pre>fig.update_xaxes(categoryorder='array', categoryarray= ['Portugal','Spain','Ireland','France', 'United Kingdom', 'Belgium', 'Netherlands', 'Switzerland', 'Italy',\n                                                        'Germany','Denmark','Norway','Austria','Sweden', 'Czech Republic', 'Slovenia', 'Croatia', 'Poland', \n                                                        'Slovak Republic', 'Hungary','Bosnia and Herzegovina', 'Albania', 'Serbia','Greece', 'Romania', \n                                                        'Bulgaria','Finland', 'Turkey'])\nfig.show()\n</pre> fig.update_xaxes(categoryorder='array', categoryarray= ['Portugal','Spain','Ireland','France', 'United Kingdom', 'Belgium', 'Netherlands', 'Switzerland', 'Italy',                                                         'Germany','Denmark','Norway','Austria','Sweden', 'Czech Republic', 'Slovenia', 'Croatia', 'Poland',                                                          'Slovak Republic', 'Hungary','Bosnia and Herzegovina', 'Albania', 'Serbia','Greece', 'Romania',                                                          'Bulgaria','Finland', 'Turkey']) fig.show() In\u00a0[136]: Copied! <pre>df = px.data.tips()\ndf.sample(10)\n</pre> df = px.data.tips() df.sample(10) Out[136]: total_bill tip sex smoker day time size 212 48.33 9.00 Male No Sat Dinner 4 5 25.29 4.71 Male No Sun Dinner 4 216 28.15 3.00 Male Yes Sat Dinner 5 16 10.33 1.67 Female No Sun Dinner 3 31 18.35 2.50 Male No Sat Dinner 4 45 18.29 3.00 Male No Sun Dinner 2 196 10.34 2.00 Male Yes Thur Lunch 2 136 10.33 2.00 Female No Thur Lunch 2 75 10.51 1.25 Male No Sat Dinner 2 239 29.03 5.92 Male No Sat Dinner 3 <p>We would like to make a bar plot that shows the total bill for men and for woman, so sex on the x-axis. We would also like to have the bars color by time (Lunch or Dinner).</p> <p>We could do the following:</p> In\u00a0[\u00a0]: Copied! <pre>fig = px.bar(df, x=\"sex\", y=\"total_bill\", color='time')\nfig.show()\n</pre> fig = px.bar(df, x=\"sex\", y=\"total_bill\", color='time') fig.show() <p>You see that you get a lot of small bars stacked on top of each other, creating white lines in the plot. If we want to get rid of these, we'll need to make a dataframe that has the sum of the total bill split up by sex and time and then plot that.</p> <p>Lucky we learned groupby yesterday! Can you help me to create the dataframe we need?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>#@title Solution\nbills = df.groupby(['sex','time']).total_bill.sum().reset_index()\nbills\n</pre> #@title Solution bills = df.groupby(['sex','time']).total_bill.sum().reset_index() bills <p>Now we can plot it easily:</p> In\u00a0[147]: Copied! <pre>fig2 = px.bar(bills, x=\"sex\", y=\"total_bill\", color='time')\nfig2.show()\n</pre> fig2 = px.bar(bills, x=\"sex\", y=\"total_bill\", color='time') fig2.show() <p>Now you see how pandas and plotly interact and complement each other.</p> <p>What we we wanted the two chunks for lunch and dinner to be next to each other instead of on top?</p> <p>We can set  the <code>barmode</code> argument to <code>group</code>:</p> In\u00a0[148]: Copied! <pre>fig3 = px.bar(bills, x=\"sex\", y=\"total_bill\",\n             color='time', barmode='group')\nfig3.show()\n</pre> fig3 = px.bar(bills, x=\"sex\", y=\"total_bill\",              color='time', barmode='group') fig3.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.histogram(df, x=\"total_bill\", title = \"Continuous variable\")\nfig.show()\n</pre> fig = px.histogram(df, x=\"total_bill\", title = \"Continuous variable\") fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.histogram(df, x=\"day\", title=\"Categorical variable\")\nfig.show()\n</pre> fig = px.histogram(df, x=\"day\", title=\"Categorical variable\") fig.show() <p><code>px.histogram()</code> also shares the <code>color</code>, <code>text_auto</code> and <code>barmode</code> argument</p> In\u00a0[\u00a0]: Copied! <pre>fig = px.histogram(df, \n                   x=\"total_bill\", \n                   color=\"sex\", \n                   text_auto=True)\nfig.show()\n</pre> fig = px.histogram(df,                     x=\"total_bill\",                     color=\"sex\",                     text_auto=True) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.histogram(df, x=\"total_bill\", nbins=20)\nfig.show()\n</pre> fig = px.histogram(df, x=\"total_bill\", nbins=20) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.histogram(df, x=\"total_bill\", histnorm='probability density')\nfig.show()\n</pre> fig = px.histogram(df, x=\"total_bill\", histnorm='probability density') fig.show() In\u00a0[149]: Copied! <pre>fig = px.histogram(df, x=\"total_bill\", y=\"tip\", histfunc='avg')\nfig.show()\n</pre> fig = px.histogram(df, x=\"total_bill\", y=\"tip\", histfunc='avg') fig.show() <p>Because the default <code>histfunc</code> is <code>sum</code>, we can actually use this to get around our earlier problem with the striped bar plots without calculating the values beforehand! How handy!</p> <p>Switch <code>px.bar</code> for <code>px.histogram</code> and pass a y-value:</p> In\u00a0[150]: Copied! <pre>fig = px.histogram(df, x=\"sex\", y=\"total_bill\",\n             color='time')\nfig.show()\n</pre> fig = px.histogram(df, x=\"sex\", y=\"total_bill\",              color='time') fig.show() <p>Compare to what we got before:</p> In\u00a0[\u00a0]: Copied! <pre>fig = px.bar(df, x=\"sex\", y=\"total_bill\", color='time')\nfig.show()\n</pre> fig = px.bar(df, x=\"sex\", y=\"total_bill\", color='time') fig.show() <ol> <li>Use the gapminder data for Oceania and show the GDPR for each year in a bar plot.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Now separate the bars into countries and put them next to each other instead of stacked on top of each other.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Have a look at the dataframe created below. What does it contain?</li> </ol> In\u00a0[176]: Copied! <pre>df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'].isin([1987,2007]))]\ndf.head()\n</pre> df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'].isin([1987,2007]))] df.head() Out[176]: country continent year lifeExp pop gdpPercap iso_alpha iso_num 19 Albania Europe 1987 72.000 3075321 3738.932735 ALB 8 23 Albania Europe 2007 76.423 3600523 5937.029526 ALB 8 79 Austria Europe 1987 74.940 7578903 23687.826070 AUT 40 83 Austria Europe 2007 79.829 8199783 36126.492700 AUT 40 115 Belgium Europe 1987 75.350 9870200 22525.563080 BEL 56 <p>Plot a histogram of this dataframe that shows the life expectancy for countries in Europe, colored by the year. Display the count inside the bar.</p> <p>How many countries had a life expectancy of less than 75 in 1987? How many had a life expectancy of less than 75 in 2007?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Bonus question: Using the tips dataset, create a chart that displays the average total bill depending on the day of the week. You will need to use a <code>histfunc</code> for this.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[178]: Copied! <pre>fig = px.violin(df, y=\"lifeExp\", x=\"year\")\nfig.show()\n</pre> fig = px.violin(df, y=\"lifeExp\", x=\"year\") fig.show() In\u00a0[\u00a0]: Copied! <pre>df = px.data.tips()\nfig = px.box(df, y=\"tip\", x=\"smoker\", color=\"sex\")\nfig.show()\n</pre> df = px.data.tips() fig = px.box(df, y=\"tip\", x=\"smoker\", color=\"sex\") fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.violin(df, y=\"tip\", x=\"smoker\", color=\"sex\")\nfig.show()\n</pre> fig = px.violin(df, y=\"tip\", x=\"smoker\", color=\"sex\") fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.violin(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points = \"all\")\nfig.show()\n</pre> fig = px.violin(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points = \"all\") fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points = False)\nfig.show()\n</pre> fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points = False) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.violin(df, y=\"tip\", x=\"smoker\", color=\"sex\", box=True)\nfig.show()\n</pre> fig = px.violin(df, y=\"tip\", x=\"smoker\", color=\"sex\", box=True) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", notched=True)\nfig.show()\n</pre> fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", notched=True) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", notched=True)\nfig.update_traces(boxmean=True)\nfig.show()\n</pre> fig = px.box(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", notched=True) fig.update_traces(boxmean=True) fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.violin(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", box=True)\nfig.update_traces(meanline_visible=True)\nfig.show()\n</pre> fig = px.violin(df, y=\"total_bill\", x=\"smoker\", color=\"sex\", points=\"all\", box=True) fig.update_traces(meanline_visible=True) fig.show() In\u00a0[188]: Copied! <pre>df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'].isin([1987,2007]))]\ndf.head()\n</pre> df = gapminder_data.loc[(gapminder_data[\"continent\"] == 'Europe') &amp; (gapminder_data['year'].isin([1987,2007]))] df.head() Out[188]: country continent year lifeExp pop gdpPercap iso_alpha iso_num 19 Albania Europe 1987 72.000 3075321 3738.932735 ALB 8 23 Albania Europe 2007 76.423 3600523 5937.029526 ALB 8 79 Austria Europe 1987 74.940 7578903 23687.826070 AUT 40 83 Austria Europe 2007 79.829 8199783 36126.492700 AUT 40 115 Belgium Europe 1987 75.350 9870200 22525.563080 BEL 56 <ol> <li>Make a boxplot of life expectancy versus the year.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Now do the same as a violin plot.</li> </ol> <p>Which one do you prefer as a visualization and why?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>We can use <code>corr</code> to see how much the variables in the tip data set are correlated with each other. Correlation can only be calculated on numerical columns.</p> In\u00a0[174]: Copied! <pre>df = px.data.tips()\ndf.corr()\n</pre> df = px.data.tips() df.corr() Out[174]: total_bill tip size total_bill 1.000000 0.675734 0.598315 tip 0.675734 1.000000 0.489299 size 0.598315 0.489299 1.000000 In\u00a0[\u00a0]: Copied! <pre>px.imshow(df.corr(), text_auto=True)\n</pre> px.imshow(df.corr(), text_auto=True) <p>We can modify the color scale using the argument <code>color_continuous_scale</code></p> In\u00a0[\u00a0]: Copied! <pre>px.imshow(df.corr(), text_auto=True, color_continuous_scale='RdBu_r')\n</pre> px.imshow(df.corr(), text_auto=True, color_continuous_scale='RdBu_r') <p>We can also explicitly map the color scale using the <code>range_color</code> argument.</p> In\u00a0[\u00a0]: Copied! <pre>px.imshow(df.corr(), text_auto= '.2f',\n          color_continuous_scale='RdBu_r', range_color=[-1,1])\n</pre> px.imshow(df.corr(), text_auto= '.2f',           color_continuous_scale='RdBu_r', range_color=[-1,1]) In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Now, do the same Africa. What do you observe? Are you surprised?</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df = px.data.gapminder().query(\"continent=='Oceania'\")\nfig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              facet_col =\"country\",\n              text=\"lifeExp\",\n              title=\"Life expectancy per year\")\n\nfig.update_traces(textposition=\"top center\")\nfig.show()\n</pre> df = px.data.gapminder().query(\"continent=='Oceania'\") fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               facet_col =\"country\",               text=\"lifeExp\",               title=\"Life expectancy per year\")  fig.update_traces(textposition=\"top center\") fig.show() In\u00a0[\u00a0]: Copied! <pre>df = px.data.iris()\ndf.head()\n</pre> df = px.data.iris() df.head() Out[\u00a0]: sepal_length sepal_width petal_length petal_width species species_id 0 5.1 3.5 1.4 0.2 setosa 1 1 4.9 3.0 1.4 0.2 setosa 1 2 4.7 3.2 1.3 0.2 setosa 1 3 4.6 3.1 1.5 0.2 setosa 1 4 5.0 3.6 1.4 0.2 setosa 1 In\u00a0[\u00a0]: Copied! <pre>fig = px.scatter(df,\n                 x=\"sepal_length\",\n                 y=\"sepal_width\",\n                 color=\"species\",\n                 marginal_x=\"box\",\n                 marginal_y=\"violin\",\n                 size='petal_width',\n                 hover_name=\"species\")\nfig.show()\n</pre> fig = px.scatter(df,                  x=\"sepal_length\",                  y=\"sepal_width\",                  color=\"species\",                  marginal_x=\"box\",                  marginal_y=\"violin\",                  size='petal_width',                  hover_name=\"species\") fig.show() <ol> <li>Can you get a scatter plot with a histogram instead of a rug distribution plot?</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Divide the previous plot using the species variable</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df = px.data.gapminder().query(\"continent=='Oceania'\")\ndf['e'] = df[\"lifeExp\"]/100 # We create an error variable just to show case\nfig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              error_y='e',\n              title=\"Life expectancy per year\")\n\nfig.update_traces(textposition=\"top left\", line = {\"dash\" : \"dot\"})\nfig.show()\n</pre> df = px.data.gapminder().query(\"continent=='Oceania'\") df['e'] = df[\"lifeExp\"]/100 # We create an error variable just to show case fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               error_y='e',               title=\"Life expectancy per year\")  fig.update_traces(textposition=\"top left\", line = {\"dash\" : \"dot\"}) fig.show() In\u00a0[\u00a0]: Copied! <pre>df = px.data.gapminder().query(\"continent=='Oceania'\")\nfig = px.line(df, x=\"year\", y=\"lifeExp\", color='country')\nfig.show()\n</pre> df = px.data.gapminder().query(\"continent=='Oceania'\") fig = px.line(df, x=\"year\", y=\"lifeExp\", color='country') fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              hover_name=\"country\",\n              hover_data = {\"country\" : False}, # we remove country from the tooltip\n              labels={\"year\": \"Year\"}, # change year for Year\n              title=\"Life expectancy per year\")\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               hover_name=\"country\",               hover_data = {\"country\" : False}, # we remove country from the tooltip               labels={\"year\": \"Year\"}, # change year for Year               title=\"Life expectancy per year\") fig.show() In\u00a0[\u00a0]: Copied! <pre>fig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              facet_col =\"country\",\n              hover_name=\"country\",\n              text=\"lifeExp\",\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              line_dash = \"country\",\n              title=\"Life expectancy per year\")\n\nfig.update_traces(textposition=\"top center\")\nfig.update_xaxes(rangeslider_visible=True)\nfig.show()\n</pre> fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               facet_col =\"country\",               hover_name=\"country\",               text=\"lifeExp\",               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               line_dash = \"country\",               title=\"Life expectancy per year\")  fig.update_traces(textposition=\"top center\") fig.update_xaxes(rangeslider_visible=True) fig.show() <ol> <li>Using the Africa's gapminder dataset, create a scatter plot with a range selector.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <ol> <li>Modify the tool tip so that when you hover over it will provide information about life expectancy, population, GDP and country code.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>df = px.data.gapminder().query(\"continent=='Oceania'\")\n\nfig = px.line(df,\n              x=\"year\",\n              y=\"lifeExp\",\n              color='country',\n              facet_col =\"country\",\n              hover_name=\"country\",\n              text=\"lifeExp\",\n              color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},\n              line_dash = \"country\",\n              title=\"Life expectancy per year\")\n\nfig.update_xaxes(\n    ticktext=[\"50s\", \"60s\", \"70s\", \"80s\", \"90s\", \"00s\"],\n    tickvals=[\"1950\", \"1960\", \"1970\", \"1980\", \"1990\", \"2000\"],\n)\nfig.show()\n</pre> df = px.data.gapminder().query(\"continent=='Oceania'\")  fig = px.line(df,               x=\"year\",               y=\"lifeExp\",               color='country',               facet_col =\"country\",               hover_name=\"country\",               text=\"lifeExp\",               color_discrete_map  = {\"Australia\":\"Black\", \"New Zealand\": \"Red\"},               line_dash = \"country\",               title=\"Life expectancy per year\")  fig.update_xaxes(     ticktext=[\"50s\", \"60s\", \"70s\", \"80s\", \"90s\", \"00s\"],     tickvals=[\"1950\", \"1960\", \"1970\", \"1980\", \"1990\", \"2000\"], ) fig.show() In\u00a0[193]: Copied! <pre>df = px.data.gapminder().query(\"continent=='Oceania'\")\n\nfig = px.bar(df, \n             y=\"country\", \n             x=\"gdpPercap\", \n             color=\"country\",\n             orientation=\"h\", \n             animation_frame=\"year\",\n             animation_group=\"country\",\n            title=\"Evolution of GDP\",\n            text=\"gdpPercap\", range_x=[5000, 40000])\n\nfig.update_traces(texttemplate='%{text:.2f}')\nfig.show()\n</pre> df = px.data.gapminder().query(\"continent=='Oceania'\")  fig = px.bar(df,               y=\"country\",               x=\"gdpPercap\",               color=\"country\",              orientation=\"h\",               animation_frame=\"year\",              animation_group=\"country\",             title=\"Evolution of GDP\",             text=\"gdpPercap\", range_x=[5000, 40000])  fig.update_traces(texttemplate='%{text:.2f}') fig.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Visualizations/plotly.html#plotly","title":"Plotly\u00b6","text":""},{"location":"Visualizations/plotly.html#python-open-source-graphing-library","title":"Python Open Source Graphing Library\u00b6","text":"<p>Plotly's Python graphing library makes interactive, publication-quality graphs. Examples of how to make line plots, scatter plots, area charts, bar charts, error bars, box plots, histograms, heatmaps, subplots, multiple-axes, polar charts, and bubble charts.</p> <p></p> <p>Plotly has an easy-to-use interface to it called Plotly express. This library makes plotting with Plotly very easy. Plotly express works nicely with Pandas dataframes as input, we just need to specify which columns need to be plotted.</p>"},{"location":"Visualizations/plotly.html#import-modules","title":"Import modules\u00b6","text":""},{"location":"Visualizations/plotly.html#introduction","title":"Introduction\u00b6","text":"<p>Let's start exploring the Plotly Database. The regular syntax for any Plotly.Express chart is <code>px.chart_type(data, parameters)</code> so let's try a simple line chart: <code>px.line(data, parameters)</code>.</p> <p>There're different ways to create the plot. We will check them all, but I think the third one makes the most sense.</p> <ol> <li>using lists of values</li> <li>using <code>pandas.Series</code></li> <li>using <code>pandas.DataFrame</code> and referencing the column names</li> </ol>"},{"location":"Visualizations/plotly.html#save-as-variable-and-show","title":"Save as variable and show\u00b6","text":"<p>We can save our plots as variables. Then, if you would like to show your plot again, you can call it using the method <code>.show()</code></p>"},{"location":"Visualizations/plotly.html#a-look-behind-the-scenes-plotly-object-structure","title":"A look behind the scenes: Plotly object structure\u00b6","text":"<p>On the background, each graph is a dictionary-like object. When you store the graph into a variable, commonly <code>fig</code>, and display this dictionary using <code>fig.to_dict()</code> or <code>fig[\"data\"]</code> or <code>fig.data</code> to see the elements data or <code>fig[\"layout\"]</code> to review the design of the plot.</p>"},{"location":"Visualizations/plotly.html#more-fun-with-line-graphs","title":"More fun with line graphs\u00b6","text":"<p>There are even more things we can do with line graphs!</p> <p>Let's use a dataframe with more rows and columns. We will make use of the gapminder dataset which is already integrated in plotly. We can load it by writing <code>px.data.gapminder</code>. Lets see what kind of dataset this is:</p>"},{"location":"Visualizations/plotly.html#color-argument","title":"Color argument\u00b6","text":"<p>As shown above, we can change the color of the lines based on a dataframe colunm by using the argument <code>color</code>. In this example, we plot the life expectancy column VS the year column and the line are colored by the content of the country column. This also gives us separate lines for the separate countries.</p>"},{"location":"Visualizations/plotly.html#color_discrete_map-argument","title":"Color_discrete_map argument\u00b6","text":"<p>We can also decide the color palette to use with <code>color_discrete_map</code>. In this case, we need to specify for each level of the variable to color by, here <code>country</code>, what color should be used:</p>"},{"location":"Visualizations/plotly.html#title-argument","title":"<code>Title</code> argument\u00b6","text":"<p>We have already seen how to change a plot's title with <code>update_layout</code>, but we can also already pass a title when we make the plot with the <code>title</code> argument.</p>"},{"location":"Visualizations/plotly.html#text-argument","title":"Text argument\u00b6","text":"<p>We can further display the value of each 'dot' in the line (from the x and y values) by using the <code>text</code> argument.</p>"},{"location":"Visualizations/plotly.html#line_dash-argument","title":"Line_dash argument\u00b6","text":"<p>By using the <code>line_dash</code> argument, we can change the dash pattern of the lines based on a variable.</p>"},{"location":"Visualizations/plotly.html#line_dash_map-argument","title":"Line_dash_map argument\u00b6","text":"<p>Similar to <code>color_discrete_map</code> there is also <code>line_dash_map</code> to specify the line type at creation.</p> <p>Note that for this to work you need to specify the <code>line_dash</code> argument (what column the dashing should depend on), otherwise a dash_map makes no sense.</p>"},{"location":"Visualizations/plotly.html#exercise-1-line-graphs","title":"Exercise 1: Line graphs\u00b6","text":"<p>Now you!</p> <ol> <li>Create a line graph of life expectancy per year for the continents 'Ocenia' and 'Africa'.</li> </ol>"},{"location":"Visualizations/plotly.html#quiz","title":"Quiz\u00b6","text":"<p>What would you do if instead of a line chart you wanted to show the data in a scatter plot?</p>"},{"location":"Visualizations/plotly.html#scatter-plots","title":"Scatter plots\u00b6","text":"<p>Scatter plots are coordinate plots that use x and y coordinates to show the relationship between two variables. However, the values of the variables do not necessarily need to be linked or ordered like in a line plot.</p> <p>Plotting a scatter plot is very much like plotting a line plot, but we use the <code>px.scatter()</code> function. Many of the arguments shown previously for the line plots work here as well, for example, the color argument:</p>"},{"location":"Visualizations/plotly.html#symbol-argument","title":"Symbol argument\u00b6","text":"<p>If you want to further differenciate the countries from each other, you can the <code>symbol</code> argument to different types of symbols, not just dots/circles.</p>"},{"location":"Visualizations/plotly.html#size-argument","title":"Size argument\u00b6","text":"<p>We can also play with the <code>size</code> of the dots to create Bubble plots</p>"},{"location":"Visualizations/plotly.html#trendline-argument","title":"Trendline argument\u00b6","text":"<p>We can easily add trendlines to our scatter plot using the argument <code>trendline</code>. By default you will use the Ordinary Least Squares trendline (linear regression).</p> <p>We quickly see the relationship between GDP and life expectancy is not linear for Europe in general.</p>"},{"location":"Visualizations/plotly.html#exercise-2-scatter-plots-and-trendlines","title":"Exercise 2: Scatter plots and trendlines\u00b6","text":"<ol> <li>Using the data from 'Africa', create a scatter plot using GDP and population. Try to make the countries as distinguishable as possible.</li> </ol>"},{"location":"Visualizations/plotly.html#bar-charts","title":"Bar Charts\u00b6","text":"<p>With <code>px.bar()</code>, each row of the DataFrame is represented as a rectangular mark. Bar plots are very useful to show quantitative information across qualitative features such as years, countries or other categorical data.</p> <p>As line and scatter plots, <code>px.bar()</code> shares a lot of arguments with line and scatter plots.</p>"},{"location":"Visualizations/plotly.html#orientation-argument","title":"Orientation argument\u00b6","text":"<p>If we would rather see horizontal bars instead of vertical, we can set the argument <code>orientation</code> to <code>\"h\"</code>. Note that we need to change the order of the <code>x</code> and <code>y</code> arguments now!</p>"},{"location":"Visualizations/plotly.html#text-on-bar-charts","title":"Text on bar charts\u00b6","text":"<p>You can add text to bars using the <code>text_auto</code> or <code>text</code> argument. <code>text_auto=True</code> will automatically use the same variable as the <code>y</code> argument, while you can use any variable with <code>text</code>.</p> <p>Let's try this with a different build-in dataset of plotly, Olympic medals:</p>"},{"location":"Visualizations/plotly.html#sorting-bar-charts","title":"Sorting bar charts\u00b6","text":"<p>We can influence the order the bars are shown in by using a <code>categoryorder</code> like so:</p> <p><code>Total ascending</code> means to sort by the total y-value in ascending order.</p>"},{"location":"Visualizations/plotly.html#stacked-vs-grouped-bars","title":"Stacked vs Grouped Bars\u00b6","text":"<p>We will not always have data that is already aggregated.</p> <p>For example, let's take the tips dataset which reports on tips given by customers and some information about the customer. It looks like this:</p>"},{"location":"Visualizations/plotly.html#histograms","title":"Histograms\u00b6","text":"<p>In statistics, a histogram is representation of the distribution of numerical data, where the data are binned and the count for each bin is represented. More generally, in Plotly a histogram is an aggregated bar chart, with several possible aggregation functions (e.g. sum, average, count...) which can be used to visualize data on categorical and date axes as well as linear axes.</p> <p>Compared to <code>px.bar()</code>, <code>px.histogram()</code> can work with only the <code>x</code> argument, which can be a continuous or categorical variable</p>"},{"location":"Visualizations/plotly.html#bins-argument","title":"Bins argument\u00b6","text":"<p>By default, the number of bins is chosen so that this number is comparable to the typical number of samples in a bin. This number can be customized, as well as the range of values, with the <code>nbins</code> argument:</p>"},{"location":"Visualizations/plotly.html#histnorm-argument","title":"Histnorm argument\u00b6","text":"<p>The default mode is to represent the count of samples in each bin. With the <code>histnorm</code> argument, it is also possible to represent the percentage or fraction of samples in each bin (<code>histnorm='percent'</code> or probability), or a <code>density histogram</code> (the sum of all bar areas equals the total number of sample points, density), or a <code>probability density histogram</code> (the sum of all bar areas equals 1, probability density).</p>"},{"location":"Visualizations/plotly.html#the-y-axis-of-histograms-histfunc","title":"The y-axis of histograms: Histfunc\u00b6","text":"<p>Usually, we do not pass a y value when we plot a  histogram because y should be the sum, i.e. how many total bills were between 0 and 10 dollar, how many between 10 and 20 dollar and so on.</p> <p>This behavior can be changed by passing a <code>histfunc</code>. This tells plotly to do something else than count the number of occurences.</p> <p>In the below example we will use the average of the tip column as the y-axis instead:</p>"},{"location":"Visualizations/plotly.html#exercise-3-bar-charts-and-histograms","title":"Exercise 3: Bar charts and histograms\u00b6","text":""},{"location":"Visualizations/plotly.html#box-plots-and-violin-plots","title":"Box plots and violin plots\u00b6","text":"<p>Box plots and violin plots are another nice way of showing data distributions. <code>px.box()</code> and <code>px.violin()</code> share almost all their arguments and can be used interchangebly.</p>"},{"location":"Visualizations/plotly.html#points-argument","title":"Points argument\u00b6","text":"<p>You can show the underlying data inside the plots by setting the argument <code>points=\"all\"</code>, to show only outliers <code>points=\"outliers\"</code> or not show any points with <code>points=False</code></p>"},{"location":"Visualizations/plotly.html#boxplot-inside-violin","title":"Boxplot inside violin\u00b6","text":"<p>You can show a boxplot inside a violin plot using <code>box=True</code></p>"},{"location":"Visualizations/plotly.html#notched-bloxplot","title":"Notched bloxplot\u00b6","text":"<p>You can add notches to your boxplot using <code>notched=True</code></p>"},{"location":"Visualizations/plotly.html#show-mean","title":"Show mean\u00b6","text":"<p>We can show the mean in our boxplot using by updating our traces using <code>boxmean=True</code> and in our violin plots using <code>meanline_visible=True</code></p>"},{"location":"Visualizations/plotly.html#exercise-4-boxplots-and-violin-plots","title":"Exercise 4: Boxplots and violin plots\u00b6","text":"<p>Again, using the following dataframe:</p>"},{"location":"Visualizations/plotly.html#heatmaps","title":"Heatmaps\u00b6","text":"<p>The <code>px.imshow()</code> function can be used to display heatmaps (as well as full-color images, as its name suggests). It accepts both array-like objects like lists of lists, as well as pandas.DataFrame objects. Heatmaps are particularly useful to display correlations between the variables of the data</p>"},{"location":"Visualizations/plotly.html#exercise-5-heatmaps","title":"Exercise 5: Heatmaps\u00b6","text":"<p>Extract info for the continent Europe from the gapminder dataset and calculate the correlation between columns. Plot the result in a heatmap. What do you observe? Are the correlations as you expected?</p> <p>Change the color scheme to something you find pleasing and add the correlation values the the squares.</p>"},{"location":"Visualizations/plotly.html#advanced-plotting","title":"Advanced plotting\u00b6","text":""},{"location":"Visualizations/plotly.html#facet_row-and-facet_col-arguments","title":"Facet_row and facet_col arguments\u00b6","text":"<p>Another cool thing we can do in many types of plots is to split the chart into rows or columns depending on a variable. For example, we can divide the information of life expectancy into different plots using the variable \"country\"</p>"},{"location":"Visualizations/plotly.html#plot-marginals","title":"Plot marginals\u00b6","text":"<p>In scatter and histogram plots, you can add extra plots on the margins (called Plot Marginals) of your scatter plot, for instance \"histogram\", \"rug\", \"box\", or \"violin\" plots. These plots can be easily added by just using the attributes: <code>marginal_x</code> and <code>marginal_y</code>.</p>"},{"location":"Visualizations/plotly.html#exercise-6-marginals-and-facets","title":"Exercise 6: Marginals and facets\u00b6","text":""},{"location":"Visualizations/plotly.html#error-argument","title":"Error argument\u00b6","text":"<p>In scatter, line and bar plots we can show error bar information, such as confidence intervals or measurement errors, using the <code>error</code> arguments. You can choose between displaying the error in the y or x axis (<code>error_y</code> and <code>error_x</code>, respectively).</p> <p>Note: You will need another variable that contains such information! Below, we create an error variable for showcasing.</p>"},{"location":"Visualizations/plotly.html#modifying-tooltips","title":"Modifying Tooltips\u00b6","text":"<p>Tooltips are the square popups that appear when you hover the mouse over a data point in the plot. We can modify the behaviour of these:</p> <ul> <li><code>hover_name</code> - highlights value of this column on the top of the tooltip</li> <li><code>hover_data</code> - let you add or remove tooltips by setting them True/False</li> <li><code>labels</code> - let you rename the column names inside the tooltip</li> </ul>"},{"location":"Visualizations/plotly.html#range-slider-and-selector-in-python","title":"Range Slider and Selector in Python\u00b6","text":"<p>You can use sliders to navigate the range of your axis. This can for instance be very useful when visualizing time-series data. (https://plotly.com/python/reference/layout/xaxis/#layout-xaxis-rangeslider)</p>"},{"location":"Visualizations/plotly.html#exercise-7-range-sliders","title":"Exercise 7: Range sliders\u00b6","text":""},{"location":"Visualizations/plotly.html#changing-axis-ticks","title":"Changing axis ticks\u00b6","text":"<p>If we do not like the ticks on our axis, we can change them using the method <code>update_xaxes()</code> or <code>update_yaxes()</code>. We will tell what texts we would like to show (<code>ticktext</code>) instead of the actual values (<code>tickvals</code>)</p>"},{"location":"Visualizations/plotly.html#animating-your-plot","title":"Animating your plot\u00b6","text":"<p>Several Plotly Express functions support the creation of animated figures through the <code>animation_frame</code> and <code>animation_group</code> arguments (https://plotly.com/python/animations/).</p> <p>In order to make the animation look nicer, we will use the <code>orientation</code> argument to make the plot horizontal. In addition, the variable <code>gdoPercap</code> has too many decimals. We can change the look of the text value by using again the <code>update_traces()</code> method, which will use text comprehension to only display 2 decimals.</p>"},{"location":"Visualizations/plotly.html#exercise-8-animations","title":"Exercise 8: Animations\u00b6","text":"<p>Recreate the above animation for data from Africa, but show the development of life expectancy over time and the GDP as text inside the bars. Remember to separate the countries.</p>"},{"location":"keywords.html","title":"Keyword index","text":"<p>Here's a lit of used keywords:</p>"},{"location":"keywords.html#authors","title":"authors","text":"<ul> <li>Contributors</li> </ul>"},{"location":"keywords.html#contributors","title":"contributors","text":"<ul> <li>Contributors</li> </ul>"}]}